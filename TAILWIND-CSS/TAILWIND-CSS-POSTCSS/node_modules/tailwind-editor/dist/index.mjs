function noop() { }
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

var Util = {
    testImgUrl(url){
		return new Promise(function(resolve) {
			const timeout = 5000;
			let timer, img = new Image();
			img.onerror = img.onabort = function() {
				clearTimeout(timer);
				resolve(false);
			};
			img.onload = function() {
				clearTimeout(timer);
				resolve(true);
			};
			timer = setTimeout(function() {
				img.src = "//!!!!/noexist.jpg";
				resolve(false);
			}, timeout); 
			img.src = url;
		});
	},

	testVideoUrl(url){
		return /^https?:\/\/.*\.(mp4|ogg|webm)$/i.test(url.trim())
	},

	parseYouTube(str) {
		// url : //youtube.com/watch?v=Bo_deCOd1HU
		// share : //youtu.be/Bo_deCOd1HU
		// embed : //youtube.com/embed/Bo_deCOd1HU
		
		const re = /\/\/(?:www\.)?youtu(?:\.be|be\.com)\/(?:watch\?v=|embed\/)?([a-z0-9_\-]+)/i; 
		const matches = re.exec(str);
		if (matches && matches[1]){
			return 'https://www.youtube.com/embed/'+matches[1]
		}
	},

	parseVimeo(str) {
		// http://vimeo.com/86164897
		
		const re = /\/\/(?:www\.)?vimeo.com\/([0-9a-z\-_]+)/i;
		const matches = re.exec(str);
		if(matches && matches[1]) {
			return 'https://player.vimeo.com/video/'+matches[1]
		}
	}
};

/* src/Editor/ContentEditor.svelte generated by Svelte v3.24.1 */

const { document: document_1 } = globals;

function add_css() {
	var style = element("style");
	style.id = "svelte-1a7fill-style";
	style.textContent = "div[contenteditable][placeholder].svelte-1a7fill:empty:before{content:attr(placeholder);position:absolute;color:#cbd5e0;background-color:transparent}";
	append(document_1.head, style);
}

// (896:1) {:else}
function create_else_block(ctx) {
	let div;
	let div_class_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = "relative " + /*gklass*/ ctx[1]);
			attr(div, "data-txteditor", "true");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = /*html*/ ctx[0];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*html*/ 1) div.innerHTML = /*html*/ ctx[0];
			if (dirty[0] & /*gklass*/ 2 && div_class_value !== (div_class_value = "relative " + /*gklass*/ ctx[1])) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (892:17) 
function create_if_block_6(ctx) {
	let h6;
	let h6_class_value;

	return {
		c() {
			h6 = element("h6");
			attr(h6, "class", h6_class_value = "relative " + /*gklass*/ ctx[1]);
			attr(h6, "data-txteditor", "true");
		},
		m(target, anchor) {
			insert(target, h6, anchor);
			h6.innerHTML = /*html*/ ctx[0];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*html*/ 1) h6.innerHTML = /*html*/ ctx[0];
			if (dirty[0] & /*gklass*/ 2 && h6_class_value !== (h6_class_value = "relative " + /*gklass*/ ctx[1])) {
				attr(h6, "class", h6_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(h6);
		}
	};
}

// (888:17) 
function create_if_block_5(ctx) {
	let h5;
	let h5_class_value;

	return {
		c() {
			h5 = element("h5");
			attr(h5, "class", h5_class_value = "relative " + /*gklass*/ ctx[1]);
			attr(h5, "data-txteditor", "true");
		},
		m(target, anchor) {
			insert(target, h5, anchor);
			h5.innerHTML = /*html*/ ctx[0];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*html*/ 1) h5.innerHTML = /*html*/ ctx[0];
			if (dirty[0] & /*gklass*/ 2 && h5_class_value !== (h5_class_value = "relative " + /*gklass*/ ctx[1])) {
				attr(h5, "class", h5_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(h5);
		}
	};
}

// (884:17) 
function create_if_block_4(ctx) {
	let h4;
	let h4_class_value;

	return {
		c() {
			h4 = element("h4");
			attr(h4, "class", h4_class_value = "relative " + /*gklass*/ ctx[1]);
			attr(h4, "data-txteditor", "true");
		},
		m(target, anchor) {
			insert(target, h4, anchor);
			h4.innerHTML = /*html*/ ctx[0];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*html*/ 1) h4.innerHTML = /*html*/ ctx[0];
			if (dirty[0] & /*gklass*/ 2 && h4_class_value !== (h4_class_value = "relative " + /*gklass*/ ctx[1])) {
				attr(h4, "class", h4_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(h4);
		}
	};
}

// (880:17) 
function create_if_block_3(ctx) {
	let h3;
	let h3_class_value;

	return {
		c() {
			h3 = element("h3");
			attr(h3, "class", h3_class_value = "relative " + /*gklass*/ ctx[1]);
			attr(h3, "data-txteditor", "true");
		},
		m(target, anchor) {
			insert(target, h3, anchor);
			h3.innerHTML = /*html*/ ctx[0];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*html*/ 1) h3.innerHTML = /*html*/ ctx[0];
			if (dirty[0] & /*gklass*/ 2 && h3_class_value !== (h3_class_value = "relative " + /*gklass*/ ctx[1])) {
				attr(h3, "class", h3_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(h3);
		}
	};
}

// (876:17) 
function create_if_block_2(ctx) {
	let h2;
	let h2_class_value;

	return {
		c() {
			h2 = element("h2");
			attr(h2, "class", h2_class_value = "relative " + /*gklass*/ ctx[1]);
			attr(h2, "data-txteditor", "true");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			h2.innerHTML = /*html*/ ctx[0];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*html*/ 1) h2.innerHTML = /*html*/ ctx[0];
			if (dirty[0] & /*gklass*/ 2 && h2_class_value !== (h2_class_value = "relative " + /*gklass*/ ctx[1])) {
				attr(h2, "class", h2_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (872:1) {#if ish1 }
function create_if_block_1(ctx) {
	let h1;
	let h1_class_value;

	return {
		c() {
			h1 = element("h1");
			attr(h1, "class", h1_class_value = "relative " + /*gklass*/ ctx[1]);
			attr(h1, "data-txteditor", "true");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			h1.innerHTML = /*html*/ ctx[0];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*html*/ 1) h1.innerHTML = /*html*/ ctx[0];
			if (dirty[0] & /*gklass*/ 2 && h1_class_value !== (h1_class_value = "relative " + /*gklass*/ ctx[1])) {
				attr(h1, "class", h1_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(h1);
		}
	};
}

// (868:0) {#if editable}
function create_if_block(ctx) {
	let div;
	let div_class_value;
	let setEditorNode_action;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			attr(div, "data-txteditor", "true");
			attr(div, "placeholder", "");
			attr(div, "spellcheck", "false");
			attr(div, "contenteditable", "true");
			attr(div, "class", div_class_value = "outline-none focus:outline-none relative " + /*gklass*/ ctx[1] + " svelte-1a7fill");
			if (/*html*/ ctx[0] === void 0) add_render_callback(() => /*div_input_handler*/ ctx[16].call(div));
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (/*html*/ ctx[0] !== void 0) {
				div.innerHTML = /*html*/ ctx[0];
			}

			if (!mounted) {
				dispose = [
					action_destroyer(setEditorNode_action = /*setEditorNode*/ ctx[12].call(null, div)),
					listen(div, "input", /*input_handler*/ ctx[13]),
					listen(div, "blur", /*blur_handler*/ ctx[14]),
					listen(div, "mousemove", /*setMouseX*/ ctx[10]),
					listen(div, "mouseup", stop_propagation(/*mouseup_handler*/ ctx[15])),
					listen(div, "input", /*div_input_handler*/ ctx[16]),
					listen(div, "keydown", /*handleKeydown*/ ctx[9]),
					listen(div, "mouseup", /*fireSelect*/ ctx[11]),
					listen(div, "keyup", /*fireSelect*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*gklass*/ 2 && div_class_value !== (div_class_value = "outline-none focus:outline-none relative " + /*gklass*/ ctx[1] + " svelte-1a7fill")) {
				attr(div, "class", div_class_value);
			}

			if (dirty[0] & /*html*/ 1 && /*html*/ ctx[0] !== div.innerHTML) {
				div.innerHTML = /*html*/ ctx[0];
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*editable*/ ctx[2]) return create_if_block;
		if (/*ish1*/ ctx[3]) return create_if_block_1;
		if (/*ish2*/ ctx[4]) return create_if_block_2;
		if (/*ish3*/ ctx[5]) return create_if_block_3;
		if (/*ish4*/ ctx[6]) return create_if_block_4;
		if (/*ish5*/ ctx[7]) return create_if_block_5;
		if (/*ish6*/ ctx[8]) return create_if_block_6;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let code_class = "code text-sm font-mono px-8 py-6 bg-gray-200";
let quote_class = "quote text-xl border-l-4 border-gray-800 px-4 font-serif";
let reg_txt_size = /md:text\-(sm\stext-sm|base\stext-base|xl\stext-lg|2xl\stext-xl|3xl\stext-xl|4xl\stext-2xl|5xl\stext-3xl|6xl\stext-4xl)/;

// duplicated, to remove!
let g_reg_txt_size = /md:text\-(sm\stext-sm|base\stext-base|xl\stext-lg|2xl\stext-xl|3xl\stext-xl|4xl\stext-2xl|5xl\stext-3xl|6xl\stext-4xl)/;

let reg_leading = /leading\-(none|tight|snug|normal|relaxed|loose)/;
let reg_position = /text\-(left|right|center)/;
let reg_txt_color = /^text\-(gray|red|yellow|green|blue|indigo|purple|pink|white|black|transparent)/;
let reg_bg_color = /^bg\-(gray|red|yellow|green|blue|indigo|purple|pink|white|black|transparent)/;
const reg_font = /font\-(thin|normal|semibold|bold|black)/;

function toggleColor(arr, klass) {
	for (let elm of arr) {
		if (elm.klass) {
			let classes = elm.klass.split(" ");

			let s_color_index = classes.findIndex(c => klass.startsWith("text")
			? reg_txt_color.test(c)
			: reg_bg_color.test(c));

			let selected_color_class = ~s_color_index ? classes[s_color_index] : "";

			if (selected_color_class) {
				// remove old selected color
				elm.klass = elm.klass.replace(selected_color_class, "").trim();
			}

			elm.klass = elm.klass.split(" ").concat([klass]).join(" ");
		} else {
			elm.klass = klass;
		}
	}
}

function toggleFont(arr, klass) {
	for (let elm of arr) {
		if (elm.klass) {
			let classes = elm.klass.split(" ");
			let s_font_index = classes.findIndex(c => reg_font.test(c));
			let selected_font_class = ~s_font_index ? classes[s_font_index] : "";

			if (selected_font_class) {
				// remove old selected color
				elm.klass = elm.klass.replace(selected_font_class, "").trim();
			}

			elm.klass = elm.klass.split(" ").concat([klass]).join(" ");
		} else {
			elm.klass = klass;
		}
	}
}

function splitArr(arr, a_i, s_i, e_i) {
	let start = s_i;
	let end = e_i || arr[a_i].txt.length;

	if (e_i && e_i < s_i) {
		start = e_i;
		end = s_i;
	}

	let s1 = arr[a_i].txt.slice(0, start);
	let s2 = arr[a_i].txt.slice(start, end);
	let arr1 = [];
	let i = 0;

	if (s1) {
		arr1[i++] = {
			txt: s1,
			klass: arr[a_i].klass,
			tag: arr[a_i].tag,
			href: arr[a_i].href
		};
	}

	if (s2) {
		arr1[i++] = {
			txt: s2,
			klass: arr[a_i].klass,
			tag: arr[a_i].tag,
			href: arr[a_i].href
		};
	}

	if (e_i && arr[a_i].txt.slice(end, arr[a_i].txt.length)) {
		arr1[i++] = {
			txt: arr[a_i].txt.slice(end, arr[a_i].txt.length),
			klass: arr[a_i].klass,
			tag: arr[a_i].tag,
			href: arr[a_i].href
		};
	}

	return arr1;
}

// return last element if index is
function getIndex(node) {
	let p_node = node;
	if (!node) return -1;

	if (node.nodeName == "DIV") {
		p_node = node.children[0];
		if (!p_node) return -1;
	} else if (["SPAN", "A"].includes(node.parentNode.tagName)) {
		p_node = node.parentNode;
	}

	return [...p_node.parentNode.childNodes].filter(n => n.nodeName != "#text" || n.length > 0).indexOf(p_node);
}

function instance($$self, $$props, $$invalidate) {
	let dispatch = createEventDispatcher();
	let arr_elms = [];
	let { html = "" } = $$props;
	let { gklass = "" } = $$props;
	let { editable = true } = $$props;

	async function generateArr() {
		let div = document.createElement("div");
		div.innerHTML = html;
		let n_elms = [];

		for (let elm of [...div.childNodes]) {
			const itrue = attr => elm.hasAttribute(attr);

			if (elm.nodeName == "BR") n_elms.push({ tag: "BR", txt: "" }); else if (elm.nodeName == "A") n_elms.push({
				tag: "A",
				txt: elm.textContent,
				href: elm.getAttribute("href"),
				klass: elm.classList && [...elm.classList].join(" ")
			}); else if (elm.nodeName == "IMG") n_elms.push({
				tag: "IMG",
				txt: elm.getAttribute("alt"),
				href: elm.getAttribute("src"),
				klass: elm.classList && [...elm.classList].join(" ")
			}); else if (elm.nodeName == "VIDEO") n_elms.push({
				tag: "VIDEO",
				href: elm.getAttribute("src"),
				klass: elm.classList && [...elm.classList].join(" "),
				opts: {
					autoplay: itrue("autoplay"),
					loop: itrue("loop"),
					muted: itrue("muted"),
					controls: itrue("controls")
				}
			}); else if (elm.dataset?.iframe) n_elms.push({
				tag: "IFRAME",
				href: elm.lastChild.getAttribute("src"),
				klass: elm.lastChild.classList && [...elm.lastChild.classList].join(" ")
			}); else if (elm.nodeName !== "#text") n_elms.push({
				txt: elm.innerText,
				klass: elm.classList && [...elm.classList].join(" ")
			}); else if (elm.nodeName == "#text" && elm.length > 0) {
				n_elms.push({ txt: elm.textContent });
			}
		}

		arr_elms = n_elms;
		await tick();
		refreshEvents();
	}

	// workaround in case using sapper!
	let mounted = false;

	onMount(() => {
		$$invalidate(18, mounted = true);
		generateArr();
	});

	const char_keys = [("B").charCodeAt(0), ("U").charCodeAt(0), ("I").charCodeAt(0)];

	async function handleKeydown(e) {
		if (e.ctrlKey && char_keys.includes(e.keyCode)) {
			e.preventDefault();
			return;
		}

		let selection = window.getSelection();
		let b_node = selection.anchorNode;
		let e_node = selection.focusNode;
		let start_i = selection.baseOffset;
		let end_i = selection.extentOffset;
		if (!b_node) return;

		let elm_node = b_node?.tagName == "DIV"
		? b_node
		: b_node.parentNode.tagName == "DIV"
			? b_node.parentNode
			: b_node.parentNode.parentNode;

		let b_index = getIndex(b_node);
		let e_index = getIndex(e_node);

		const adjustPosition = (n, d = "up") => {
			let children = [...n.childNodes];
			let last_child = children[children.length - 1];
			if (!last_child) return;

			last_child = ["#text", "BR", "IMG", "VIDEO"].includes(last_child.nodeName) || last_child?.dataset?.iframe
			? last_child
			: last_child.childNodes[0];

			if (!last_child) return false;
			let pos = d == "up" ? last_child.textContent.length : 0;
			selection.setBaseAndExtent(last_child, pos, last_child, pos);
		};

		// up key
		if (e.keyCode == 38) {
			if (b_node == e_node && start_i == 0 && b_index <= 0) {
				// move to the previous node
				let pv_elm = elm_node.previousElementSibling;

				// TODO - fix workaround
				while (pv_elm && pv_elm.previousElementSibling && !pv_elm.isContentEditable) {
					pv_elm = pv_elm.previousElementSibling;
				}

				if (pv_elm && pv_elm.isContentEditable) {
					pv_elm.focus();
					e.preventDefault();
					adjustPosition(pv_elm, "up");
					return false;
				}
			}
		}

		// down key
		if (e.keyCode == 40) {
			// get index
			if (b_node == e_node) {
				// if(b_index == arr_elms.length-1 || (b_index == arr_elms.length-2 && arr_elms[arr_elms.length-1].tag == 'BR') || b_node == elm_node){
				if (b_index == arr_elms.length - 1 || (b_index == -1 || start_i == arr_elms.length - 1) && arr_elms[arr_elms.length - 1].tag == "BR") {
					let next_elm = elm_node.nextElementSibling;

					while (next_elm && next_elm.nextElementSibling && !next_elm.isContentEditable) {
						next_elm = next_elm.nextElementSibling;
					}

					if (next_elm && next_elm.isContentEditable) {
						next_elm.focus();
						e.preventDefault();

						//adjustPosition(next_elm, 'down')
						return false;
					}
				}
			}
		}

		// del key
		if (e.keyCode == 46) {
			let elms = arr_elms.length && arr_elms[arr_elms.length - 1].tag == "BR"
			? arr_elms.slice(0, arr_elms.length - 1)
			: arr_elms;

			if (!~b_index && !elms.length || b_node.tagName == "DIV" && b_index == 0 && start_i == elms.length || b_index == elms.length - 1 && start_i == elms[elms.length - 1].txt?.length && !selection.toString()) {
				let l_node_index;
				let l_node_end;
				let pv_elm = elm_node;

				if (pv_elm && pv_elm.isContentEditable) {
					if (!pv_elm.childNodes.length) pv_elm.focus(); else {
						l_node_index = pv_elm.childNodes.length - 1;
						l_node_end = pv_elm.childNodes[pv_elm.childNodes.length - 1].textContent.length;
					}
				}

				dispatch("merge_next");
				e.preventDefault();
				await new Promise(r => setTimeout(r));

				if (l_node_index !== undefined) {
					let l_node = pv_elm.childNodes[l_node_index];

					if (l_node.nodeName !== "#text" && l_node.nodeName !== "BR") {
						l_node = l_node.childNodes[0];
					}

					selection.setBaseAndExtent(l_node, l_node_end, l_node, l_node_end);
				}

				return;
			}
		}

		// back key
		if (e.keyCode == 8) {
			if (start_i == 0 && (b_index == 0 || b_index == -1)) {
				let l_node_index;
				let l_node_end;
				let pv_elm = elm_node.previousElementSibling;

				// STEP to skip grammarly (woraround for now!) -- TODO - fix
				if (pv_elm && !pv_elm.isContentEditable) pv_elm = pv_elm.previousElementSibling;

				if (pv_elm && pv_elm.isContentEditable) {
					if (!pv_elm.childNodes.length) {
						pv_elm.focus();
					} else {
						l_node_index = pv_elm.childNodes.length - 1;
						l_node_end = pv_elm.childNodes[pv_elm.childNodes.length - 1].textContent.length;
					}
				}

				e.preventDefault();
				dispatch("merge_prev", html);
				await new Promise(r => setTimeout(r));

				if (l_node_index !== undefined) {
					let l_node = pv_elm.childNodes[l_node_index];

					if (l_node.nodeName !== "#text" && l_node.nodeName !== "BR") {
						l_node = l_node.childNodes[0];
					}

					selection.setBaseAndExtent(l_node, l_node_end, l_node, l_node_end);
				}
			}
		}

		// enter key
		if (e.keyCode == 13 && e.shiftKey == false) {
			let elm_html = "";
			let next_html = "";

			let elm_index = b_index == -1
			? arr_elms.length - 1
			: b_index + (b_node.tagName == "DIV" && start_i > 0 ? start_i - 1 : 0);

			if (arr_elms.length > 0 && ~b_index) {
				let n_arr = splitArr(arr_elms, elm_index, start_i);
				arr_elms.splice(elm_index, 1, ...n_arr);
				let s_index = elm_index + (start_i == 0 ? 0 : 1);
				elm_html = extractHTML(arr_elms.slice(0, s_index));
				next_html = extractHTML(arr_elms.slice(s_index, arr_elms.length));
			}

			if (!~b_index) {
				elm_html = extractHTML(arr_elms);
			}

			dispatch("enter", {
				html: elm_html.trim(),
				next_html: next_html.trim(),
				klass: gklass,
				target: e.currentTarget
			});

			e.preventDefault();
			return false;
		}

		if (e.keyCode == 13 && e.shiftKey == true) {
			let div_elm = b_node.nodeName != "#text"
			? b_node.parentNode
			: b_node.parentNode.parentNode;

			await new Promise(r => setTimeout(r));

			// not in rooot
			if (b_node.nodeName != "DIV" && (b_node.parentNode && b_node.parentNode.tagName != "DIV" || !["BR", "#text"].includes(b_node.nodeName))) {
				let parent = b_node.nodeName != "#text" ? b_node : b_node.parentNode;

				//div_elm = parent.parentNode ? parent.parentNode : div_elm
				if (!parent.parentNode) {
					refresh();
					await new Promise(r => setTimeout(r));
					let p_elm = div_elm.childNodes[b_index];
					selection.setBaseAndExtent(p_elm, 0, p_elm, 0);
					return;
				}

				// parent child text nodes
				let children = [...parent.childNodes];

				let elms = [];

				for (let ch of children) {
					if (ch && ch.textContent) {
						elms.push({
							txt: ch.textContent,
							klass: arr_elms[b_index]?.klass || "",
							tag: parent.tagName
						});
					} else {
						elms.push({ tag: "BR", txt: "" });
					}
				}

				arr_elms.splice(b_index, 1, ...elms);
				refresh();
				await new Promise(r => setTimeout(r));
				let p_elm = div_elm.childNodes[elms[0].tag == "BR" ? b_index : b_index + 2];
				selection.setBaseAndExtent(p_elm, 0, p_elm, 0);
			}
		}
	}

	function extractHTML(arr) {
		let str = "";

		arr.forEach(elm => {
			let elm_txt = elm.txt;

			if (elm.txt) {
				elm_txt = elm.txt.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
			}

			if (elm.tag == "BR") {
				str += "<br>";
			} else if (elm.tag == "A") {
				str += `<a href=${elm.href} target='_blank' class="${elm.klass}">${elm_txt}</a>`;
			} else if (elm.tag == "IMG") {
				str += `<img src=${elm.href} class="${elm.klass}" alt=${elm_txt} />`;
			} else if (elm.tag == "VIDEO") {
				str += `<video src=${elm.href} class="${elm.klass}" ${!!elm.opts?.loop ? "loop" : ""} ${!!elm.opts?.autoplay ? "autoplay" : ""} ${!!elm.opts?.muted ? "muted" : ""} ${!!elm.opts?.controls ? "controls" : ""} />`;
			} else if (elm.tag == "IFRAME") {
				let ed_str = "";

				if (editable) {
					ed_str = `<div class="p-1 text-xs w-32 bg-yellow-200 text-yellow-800 cursor-pointer underline text-center">
						Edit iframe
					</div>`;
				}

				str += `<div class="iframe-wrap" data-iframe="true" contenteditable="false">
					${ed_str}
					<iframe src=${elm.href} class="${elm.klass}" />
				</div>`;
			} else if (elm.klass) {
				str += `<span class="${elm.klass}">${elm_txt}</span>`;
			} else {
				str += elm_txt;
			}
		});

		return str;
	}

	function refresh() {
		$$invalidate(0, html = extractHTML(arr_elms));
	}

	let l_edit_state = editable;

	function refreshEvents() {
		if (!edit_node) return;

		[...edit_node.childNodes].forEach((ch, i) => {
			if (["IMG", "VIDEO"].includes(ch.nodeName) || ch.classList?.contains("iframe-wrap")) {
				ch.addEventListener("click", e => editMedia(e.currentTarget, i));
			}
		});
	}

	let h_selection = null;

	async function holdSelection(selection) {
		if (h_selection) return;

		h_selection = {
			start_i: selection.baseOffset,
			end_i: selection.extentOffset,
			b_node: selection.anchorNode,
			e_node: selection.focusNode
		};
	}

	async function setClass(class_name, link) {
		arr_elms.forEach(e => delete e.selected);
		let selection = window.getSelection();
		let selection_txt = selection.toString();
		let start_i = h_selection ? h_selection.start_i : selection.baseOffset;
		let end_i = h_selection ? h_selection.end_i : selection.extentOffset;
		let b_node = h_selection ? h_selection.b_node : selection.anchorNode;
		let e_node = h_selection ? h_selection.e_node : selection.focusNode;
		let b_index = getIndex(b_node);
		let e_index = getIndex(e_node);
		let same_node = b_node == e_node;
		let reverse = b_index > e_index;
		let sb_index = b_index;
		let se_index = e_index;

		if (reverse) {
			sb_index = e_index;
			se_index = b_index;
			let x = start_i;
			start_i = end_i;
			end_i = x;
		}

		let edit_node = b_node.parentNode;

		if (b_node.parentNode.tagName !== "DIV") {
			edit_node = edit_node.parentNode;
		}

		let n_arr = arr_elms.slice(sb_index, se_index + 1);
		let arr1 = splitArr(n_arr, 0, start_i, same_node && end_i);

		let up_arr = arr1.length == 1
		? arr1
		: arr1.length == 2 && (start_i == 0 || end_i == 0)
			? [arr1[0]]
			: [arr1[1]];

		n_arr.splice(0, 1, ...arr1);
		let arr2 = [];

		if (!same_node) {
			arr2 = splitArr(n_arr, n_arr.length - 1, end_i, false);
			n_arr.splice(n_arr.length - 1, 1, ...arr2);
			up_arr = up_arr.concat(n_arr.slice(1, n_arr.length - (arr2.length == 1 ? 0 : 1)));
		}

		toggleClass(up_arr, class_name, link);
		up_arr.forEach(e => e.selected = true);
		arr_elms.splice(sb_index, se_index - sb_index + 1, ...n_arr);
		let p_selector = {};
		mergeArr(p_selector);
		refresh();
		h_selection = null;
		await tick();
		let ch_nodes = [...edit_node.childNodes].filter(elm => elm.nodeName !== "#text" || elm.nodeName == "#text" && elm.length > 0);
		let start_node = ch_nodes[p_selector.a_start];
		let end_node = ch_nodes[p_selector.a_end];

		start_node = start_node.nodeName == "#text"
		? start_node
		: start_node.firstChild;

		end_node = end_node.nodeName == "#text"
		? end_node
		: end_node.firstChild;

		await new Promise(r => setTimeout(r));
		window.getSelection().removeAllRanges();
		window.getSelection().setBaseAndExtent(start_node, p_selector.s_start, end_node, p_selector.s_end);
		holdSelection(window.getSelection());
	}

	async function setGClass(klass) {
		if (klass) {
			if (reg_txt_size.test(klass)) {
				$$invalidate(1, gklass = gklass.replace(code_class, "").replace(quote_class, "").trim());
				replaceGClass(klass, reg_txt_size);
			} else if (klass.startsWith("code")) {
				if (!gklass.includes(code_class)) {
					$$invalidate(1, gklass = gklass.replace(quote_class, "").replace(g_reg_txt_size, "").trim());
					$$invalidate(1, gklass += " " + code_class);
				}
			} else if (klass.startsWith("quote")) {
				if (!gklass.includes(quote_class)) {
					$$invalidate(1, gklass = gklass.replace(code_class, "").replace(g_reg_txt_size, "").trim());
					$$invalidate(1, gklass += " " + quote_class);
				}
			} else if (reg_position.test(klass)) {
				replaceGClass(klass, reg_position);
			} else if (reg_leading.test(klass)) {
				replaceGClass(klass, reg_leading);
			} else {
				toggleGClass(klass);
			}
		} else {
			elm.klass = klass;
		}

		dispatch("changeClass");
	}

	function mergeArr(p_selector) {
		let n_arr = [{ ...arr_elms[0] }];

		if (arr_elms[0].selected) {
			p_selector.s_start = 0;
			p_selector.a_start = 0;
			p_selector.s_end = arr_elms[0].txt.length;
			p_selector.a_end = 0;
		}

		for (let i = 1; i < arr_elms.length; i++) {
			if (arr_elms[i].txt && arr_elms[i].tag == arr_elms[i - 1].tag && arr_elms[i].klass == arr_elms[i - 1].klass) {
				if (arr_elms[i].selected && !arr_elms[i - 1].selected) {
					p_selector.s_start = n_arr[n_arr.length - 1].txt.length;
					p_selector.a_start = n_arr.length - 1;
					p_selector.s_end = n_arr[n_arr.length - 1].txt.length + arr_elms[i].txt.length;
					p_selector.a_end = n_arr.length - 1;
				}

				n_arr[n_arr.length - 1].txt += arr_elms[i].txt;
			} else {
				if (arr_elms[i].txt) {
					n_arr.push({ ...arr_elms[i] });

					if (arr_elms[i].selected && !arr_elms[i - 1].selected) {
						p_selector.s_start = 0;
						p_selector.a_start = n_arr.length - 1;
						p_selector.s_end = n_arr[n_arr.length - 1].txt.length;
						p_selector.a_end = n_arr.length - 1;
					}
				} else if (arr_elms[i].tag == "BR") {
					n_arr.push({ ...arr_elms[i] });
				}
			}

			if (arr_elms[i].selected && arr_elms[i - 1].selected) {
				p_selector.s_end = n_arr[n_arr.length - 1].txt.length;
				p_selector.a_end = n_arr.length - 1;
			}
		}

		arr_elms = n_arr;
	}

	function toggleGClass(klass) {
		if (gklass.includes(klass)) {
			$$invalidate(1, gklass = gklass.replace(klass, "").trim());
		} else {
			$$invalidate(1, gklass = gklass.split(" ").concat([klass]).join(" "));
		}
	}

	function replaceGClass(klass, reg) {
		// let classes = gklass.split(' ')
		// let s_index = classes.findIndex(c => reg.test(c))
		// let selected_class = ~s_index ? classes[s_index] : ''
		// if(selected_class){
		// 	gklass = gklass.replace(selected_class,'').trim()
		// }
		// gklass = gklass.split(' ').concat([klass]).join(' ')
		$$invalidate(1, gklass = gklass.replace(reg, "").replace(/\s+/, " ").trim());

		$$invalidate(1, gklass = gklass + " " + klass);
	}

	function toggleClass(arr, klass, link) {
		if (reg_txt_color.test(klass) || reg_bg_color.test(klass)) {
			toggleColor(arr, klass);
			dispatch("changeClass");
			return;
		}

		if (reg_font.test(klass)) {
			toggleFont(arr, klass);
			dispatch("changeClass");
			return;
		}

		if (arr.find(e => e.tag != "BR" && (!e.klass || !e.klass.includes(klass)))) {
			for (let elm of arr) {
				if (elm.tag != "BR" && link) {
					elm.tag = "A";
					elm.href = link;
				}

				if (!elm.klass || !elm.klass.includes(klass)) {
					elm.klass = elm.klass
					? elm.klass.split(" ").concat([klass]).join(" ")
					: klass;

					elm.tag = elm.tag;
				}
			}
		} else {
			for (let elm of arr) {
				if (elm.tag != "BR" && link) {
					elm.tag = "A";
					elm.href = link;
				}

				if (!link && elm.tag != "IMG" && elm.klass && elm.klass.includes("link")) {
					delete elm.href;
					delete elm.tag;
				}

				elm.klass = (elm.klass || "") && elm.klass.replace(klass, "").trim();
				if (elm.klass == "") delete elm.klass;
			}
		}

		dispatch("changeClass");
	}

	// EVENT FN
	function extractClasses(b_index, e_index) {
		if (b_index > e_index) {
			let x = b_index;
			b_index = e_index;
			e_index = x;
		}

		let arr_slice = arr_elms.slice(b_index, e_index + 1);
		if (!arr_slice[0] || !arr_slice[0].klass) return "";
		let b_class = arr_slice[0].klass;

		// find similar classes
		let arr_classes = b_class.split(" ");

		// if word not found remove it
		for (let i = 1; i < arr_slice.length; i++) {
			// get all the common classes!
			let elm = arr_slice[i];

			for (let w_class of arr_classes) {
				if (elm.klass && !elm.klass.includes(w_class)) {
					b_class = b_class.replace(w_class, "").trim();
				}
			}
		}

		return b_class;
	}

	function extractLink(b_index, e_index) {
		if (b_index > e_index) {
			let x = b_index;
			b_index = e_index;
			e_index = x;
		}

		let arr_slice = arr_elms.slice(b_index, e_index + 1);
		let href = "";

		for (let i = 0; i < arr_slice.length; i++) {
			// get all the common classes!
			let elm = arr_slice[i];

			if (elm.href) {
				href = elm.href;
				break;
			}
		}

		return href;
	}

	function setClasses(media) {
		let zmatch = media.klass.match(/z-\d+/);
		let z = zmatch?.[0] || "";
		let floatmatch = media.klass.match(/float-\w+/);
		let float = floatmatch?.[0] || "";

		if (z) {
			$$invalidate(1, gklass = gklass.replace(/z-\d+/, ""));
		}

		if (float) {
			$$invalidate(1, gklass = gklass.replace(/float-\w+/, ""));
		}

		$$invalidate(1, gklass += ` ${z} ${float} `);
		$$invalidate(1, gklass = gklass.replace(/\s+/g, " "));
		media.klass = media.klass.replace(/z-\d+/, "").replace(/float-\w+/, "");
	}

	// embed image or video!
	async function embedElement(e, b_node, b_index) {
		//TODO key code is not up/down/left/right
		let src = b_node.textContent.split(" ").pop();

		if (src && src.startsWith("https")) {
			let is_img = await Util.testImgUrl(src.trim());
			let is_video = Util.testVideoUrl(src.trim());
			let iframe_vid = Util.parseYouTube(src.trim()) || Util.parseVimeo(src.trim());

			if (is_img || is_video || iframe_vid) {
				dispatch("set_media", {
					setMedia: img => {
						setClasses(img);
						if (is_img) setImg(img.klass, img.alt, src, b_index); else if (is_video) setVideo(img.klass, img.opts, src, b_index); else if (iframe_vid) setIframe(img.klass, iframe_vid, b_index);
					},
					media_type: is_img
					? "IMG"
					: is_video ? "VIDEO" : iframe_vid ? "IFRAME" : "AUDIO",
					base_node: b_node,
					src: iframe_vid || src,
					delMedia: () => delElm(b_index),
					mouseX
				});
			}
		}
	}

	function editMedia(b_node, i) {
		let elm = arr_elms[i];
		let extra = { alt: elm?.txt || "" };
		if (b_node.tagName == "VIDEO") extra = { opts: elm?.opts || {} };

		// if(b_node.classList?.contains('iframe-wrap')){
		// 	b_node = b_node.lastChild
		// }
		dispatch("set_media", {
			setMedia: img => {
				setClasses(img);

				if (img.media_type == "VIDEO") {
					setVideo(img.klass, img.opts, img.src, i);
				} else if (img.media_type == "IMG") {
					setImg(img.klass, img.alt, img.src, i);
				} else if (img.media_type == "IFRAME") {
					setIframe(img.klass, img.src, i);
				}
			},
			base_node: b_node,
			media_type: b_node.tagName,
			src: elm?.href || "",
			klass: elm?.klass || "",
			...extra,
			delMedia: () => delElm(i),
			mouseX
		});
	}

	function delElm(b_index) {
		arr_elms.splice(b_index, 1);
		refresh();
	}

	function setImg(klass, alt, src, b_index) {
		arr_elms[b_index] = { tag: "IMG", href: src, txt: alt, klass };
		refresh();
	}

	function setVideo(klass, opts, src, b_index) {
		arr_elms[b_index] = { tag: "VIDEO", href: src, opts, klass };
		refresh();
	}

	function setIframe(klass, src, b_index) {
		arr_elms[b_index] = { tag: "IFRAME", href: src, klass };
		refresh();
	}

	let mouseX;

	function setMouseX(e) {
		mouseX = e.clientX;
	}

	function fireSelect(e) {
		let selection = window.getSelection();
		let selection_txt = selection.toString();
		let b_node = selection.anchorNode;
		let e_node = selection.focusNode;
		let b_index = getIndex(b_node);
		let e_index = getIndex(e_node);
		if (!b_node?.nodeName) return;

		if (b_node.nodeName == "DIV" || e_node.nodeName == "DIV") {
			hideSelect();
			return;
		}

		h_selection = null;

		if (selection_txt) {
			holdSelection(selection);

			// extract classes to pass them to the toolbar!
			let classes = extractClasses(b_index, e_index);

			let href = extractLink(b_index, e_index);

			dispatch("select", {
				setClass,
				setGClass,
				base_node: b_node,
				classes,
				g_classes: gklass,
				href,
				mouseX
			});
		} else {
			embedElement(e, b_node, b_index);
			hideSelect();
		}
	}

	function hideSelect() {
		dispatch("hideselect");
	}

	let edit_node;

	function setEditorNode(node) {
		edit_node = node;
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function blur_handler(event) {
		bubble($$self, event);
	}

	function mouseup_handler(event) {
		bubble($$self, event);
	}

	function div_input_handler() {
		html = this.innerHTML;
		$$invalidate(0, html);
	}

	$$self.$$set = $$props => {
		if ("html" in $$props) $$invalidate(0, html = $$props.html);
		if ("gklass" in $$props) $$invalidate(1, gklass = $$props.gklass);
		if ("editable" in $$props) $$invalidate(2, editable = $$props.editable);
	};

	let ish1;
	let ish2;
	let ish3;
	let ish4;
	let ish5;
	let ish6;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*mounted, html*/ 262145) {
			 if (mounted) {
				if (html) generateArr(); else arr_elms = [];
			}
		}

		if ($$self.$$.dirty[0] & /*editable*/ 4) {
			 if (editable) {
				setTimeout(refreshEvents);
			}
		}

		if ($$self.$$.dirty[0] & /*l_edit_state, editable*/ 524292) {
			 if (l_edit_state != editable) {
				$$invalidate(19, l_edit_state = editable);
				refresh();
			}
		}

		if ($$self.$$.dirty[0] & /*gklass*/ 2) {
			 $$invalidate(3, ish1 = gklass.includes("text-6xl"));
		}

		if ($$self.$$.dirty[0] & /*gklass*/ 2) {
			 $$invalidate(4, ish2 = gklass.includes("text-5xl"));
		}

		if ($$self.$$.dirty[0] & /*gklass*/ 2) {
			 $$invalidate(5, ish3 = gklass.includes("text-4xl"));
		}

		if ($$self.$$.dirty[0] & /*gklass*/ 2) {
			 $$invalidate(6, ish4 = gklass.includes("text-3xl"));
		}

		if ($$self.$$.dirty[0] & /*gklass*/ 2) {
			 $$invalidate(7, ish5 = gklass.includes("text-2xl"));
		}

		if ($$self.$$.dirty[0] & /*gklass*/ 2) {
			 $$invalidate(8, ish6 = gklass.includes("text-xl"));
		}
	};

	return [
		html,
		gklass,
		editable,
		ish1,
		ish2,
		ish3,
		ish4,
		ish5,
		ish6,
		handleKeydown,
		setMouseX,
		fireSelect,
		setEditorNode,
		input_handler,
		blur_handler,
		mouseup_handler,
		div_input_handler
	];
}

class ContentEditor extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1.getElementById("svelte-1a7fill-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { html: 0, gklass: 1, editable: 2 }, [-1, -1]);
	}
}

/* src/Icons/NoColor.svelte generated by Svelte v3.24.1 */

function create_fragment$1(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M8.46457 14.1213C8.07404 14.5118 8.07404 15.145 8.46457 15.5355C8.85509 15.926 9.48825 15.926 9.87878 15.5355L15.5356 9.87862C15.9262 9.4881 15.9262 8.85493 15.5356 8.46441C15.1451 8.07388 14.5119 8.07388 14.1214 8.46441L8.46457 14.1213Z");
			attr(path0, "fill", "currentColor");
			attr(path1, "fill-rule", "evenodd");
			attr(path1, "clip-rule", "evenodd");
			attr(path1, "d", "M6.34315 17.6569C9.46734 20.781 14.5327 20.781 17.6569 17.6569C20.781 14.5327 20.781 9.46734 17.6569 6.34315C14.5327 3.21895 9.46734 3.21895 6.34315 6.34315C3.21895 9.46734 3.21895 14.5327 6.34315 17.6569ZM16.2426 16.2426C13.8995 18.5858 10.1005 18.5858 7.75736 16.2426C5.41421 13.8995 5.41421 10.1005 7.75736 7.75736C10.1005 5.41421 13.8995 5.41421 16.2426 7.75736C18.5858 10.1005 18.5858 13.8995 16.2426 16.2426Z");
			attr(path1, "fill", "currentColor");
			attr(svg, "class", "w-4 h-4 text-red-700 fill-current");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class NoColor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$1, safe_not_equal, {});
	}
}

/* src/ToolBar/ColorList.svelte generated by Svelte v3.24.1 */

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	child_ctx[10] = i;
	return child_ctx;
}

// (33:4) {#each colors as color}
function create_each_block_1(ctx) {
	let div;
	let div_class_value;
	let mounted;
	let dispose;

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[6](/*color*/ ctx[11], /*i*/ ctx[10], ...args);
	}

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = "bg-" + /*color*/ ctx[11] + "-" + (/*i*/ ctx[10] + 1) * 100 + " w-5 h-5 cursor-pointer");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = listen(div, "click", click_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (31:2) {#each (new Array(8)) as num,i}
function create_each_block(ctx) {
	let div;
	let t;
	let each_value_1 = /*colors*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(div, "class", "flex");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*colors, selectColor*/ 3) {
				each_value_1 = /*colors*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let div5;
	let div4;
	let div3;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;
	let nocolor;
	let t2;
	let current;
	let mounted;
	let dispose;
	nocolor = new NoColor({});
	let each_value = new Array(8);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div5 = element("div");
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			create_component(nocolor.$$.fragment);
			t2 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "bg-black  w-5 h-5 cursor-pointer");
			attr(div1, "class", "bg-white border border-gray-400 w-5 h-5 cursor-pointer");
			attr(div2, "class", "bg-white border-t border-b border-r border-gray-400 w-5 h-5 flex items-center justify-center cursor-pointer");
			attr(div3, "class", "flex items-center");
			attr(div4, "class", "shadow-xl border border-gray-200");
			attr(div5, "class", "flex");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div4);
			append(div4, div3);
			append(div3, div0);
			append(div3, t0);
			append(div3, div1);
			append(div3, t1);
			append(div3, div2);
			mount_component(nocolor, div2, null);
			append(div4, t2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div4, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*click_handler*/ ctx[3]),
					listen(div1, "click", /*click_handler_1*/ ctx[4]),
					listen(div2, "click", /*click_handler_2*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*colors, selectColor*/ 3) {
				each_value = new Array(8);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div4, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(nocolor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(nocolor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			destroy_component(nocolor);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let dispatch = createEventDispatcher();
	let { selected_color = "" } = $$props;
	let colors = ["gray", "red", "yellow", "green", "blue", "indigo", "purple", "pink"];

	function selectColor(e, color) {
		$$invalidate(2, selected_color = color);
		dispatch("select", color);
		e.preventDefault();
		e.stopPropagation();
	}

	const click_handler = e => selectColor(e, `black`);
	const click_handler_1 = e => selectColor(e, `white`);
	const click_handler_2 = e => selectColor(e, `transparent`);
	const click_handler_3 = (color, i, e) => selectColor(e, `${color}-${(i + 1) * 100}`);

	$$self.$$set = $$props => {
		if ("selected_color" in $$props) $$invalidate(2, selected_color = $$props.selected_color);
	};

	return [
		colors,
		selectColor,
		selected_color,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3
	];
}

class ColorList extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$2, safe_not_equal, { selected_color: 2 });
	}
}

/* src/Icons/DownIcon.svelte generated by Svelte v3.24.1 */

function create_fragment$3(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M6.34317 7.75732L4.92896 9.17154L12 16.2426L19.0711 9.17157L17.6569 7.75735L12 13.4142L6.34317 7.75732Z");
			attr(path, "fill", "currentColor");
			attr(svg, "class", "w-4 h-4 text-gray-700");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class DownIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$3, safe_not_equal, {});
	}
}

/* src/ToolBar/ColorPicker.svelte generated by Svelte v3.24.1 */

function create_if_block$1(ctx) {
	let div;
	let colorlist;
	let current;

	colorlist = new ColorList({
			props: {
				selected_color: /*selected_color*/ ctx[2]
			}
		});

	colorlist.$on("select", /*selectColor*/ ctx[3]);

	return {
		c() {
			div = element("div");
			create_component(colorlist.$$.fragment);
			attr(div, "class", "absolute top-0 left-0 mt-8 z-920 bg-white");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(colorlist, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const colorlist_changes = {};
			if (dirty & /*selected_color*/ 4) colorlist_changes.selected_color = /*selected_color*/ ctx[2];
			colorlist.$set(colorlist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(colorlist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(colorlist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(colorlist);
		}
	};
}

function create_fragment$4(ctx) {
	let div1;
	let div0;
	let span;
	let t1;
	let downicon;
	let div0_class_value;
	let t2;
	let current;
	let mounted;
	let dispose;
	downicon = new DownIcon({});
	let if_block = /*show_colors*/ ctx[1] && create_if_block$1(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			span.textContent = "A";
			t1 = space();
			create_component(downicon.$$.fragment);
			t2 = space();
			if (if_block) if_block.c();
			attr(span, "class", "");
			attr(div0, "class", div0_class_value = "font-medium flex items-center cursor-pointer " + /*txt*/ ctx[0] + "-" + /*selected_color*/ ctx[2] + " px-1");
			attr(div1, "class", "flex relative");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, span);
			append(div0, t1);
			mount_component(downicon, div0, null);
			append(div1, t2);
			if (if_block) if_block.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "click", /*hideColors*/ ctx[5]),
					listen(div0, "click", /*showColors*/ ctx[4])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*txt, selected_color*/ 5 && div0_class_value !== (div0_class_value = "font-medium flex items-center cursor-pointer " + /*txt*/ ctx[0] + "-" + /*selected_color*/ ctx[2] + " px-1")) {
				attr(div0, "class", div0_class_value);
			}

			if (/*show_colors*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*show_colors*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(downicon.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(downicon.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(downicon);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { txt = "text" } = $$props;
	let { setClass } = $$props;
	let { klass } = $$props;
	let colors = ["gray", "red", "yellow", "green", "blue", "indigo", "purple", "pink"];
	let show_colors = false;
	let selected_color = "blue-500";

	function selectColor(evt) {
		setClass(txt + "-" + evt.detail);
		$$invalidate(2, selected_color = evt.detail);
	}

	function showColors(e) {
		$$invalidate(1, show_colors = !show_colors);
		e.stopPropagation();
		e.preventDefault();
	}

	function hideColors() {
		$$invalidate(1, show_colors = false);
	}

	$$self.$$set = $$props => {
		if ("txt" in $$props) $$invalidate(0, txt = $$props.txt);
		if ("setClass" in $$props) $$invalidate(6, setClass = $$props.setClass);
		if ("klass" in $$props) $$invalidate(7, klass = $$props.klass);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*klass, txt*/ 129) {
			 if (klass) {
				let classes = klass.split(" ");
				let reg = new RegExp(txt + "\\-(" + colors.join("|") + ")");
				let s_color_index = classes.findIndex(c => reg.test(c));

				$$invalidate(2, selected_color = ~s_color_index
				? classes[s_color_index].replace(txt + "-", "")
				: "");
			}
		}
	};

	return [
		txt,
		show_colors,
		selected_color,
		selectColor,
		showColors,
		hideColors,
		setClass,
		klass
	];
}

class ColorPicker extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$4, safe_not_equal, { txt: 0, setClass: 6, klass: 7 });
	}
}

/* src/Icons/CodeIcon.svelte generated by Svelte v3.24.1 */

function create_fragment$5(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M9.95263 16.9123L8.59323 18.3608L2.03082 12.2016L8.18994 5.63922L9.64826 7.00791L4.85783 12.112L9.95212 16.8932L9.95263 16.9123Z");
			attr(path0, "fill", "currentColor");
			attr(path1, "d", "M14.0474 16.9123L15.4068 18.3608L21.9692 12.2016L15.8101 5.63922L14.3517 7.00791L19.1422 12.112L14.0479 16.8932L14.0474 16.9123Z");
			attr(path1, "fill", "currentColor");
			attr(svg, "class", "w-4 h-4");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class CodeIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$5, safe_not_equal, {});
	}
}

/* src/ToolBar/LinkInput.svelte generated by Svelte v3.24.1 */

function create_if_block$2(ctx) {
	let div;
	let input;
	let t0;
	let button0;
	let t2;
	let button1;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			input = element("input");
			t0 = space();
			button0 = element("button");
			button0.textContent = "Link";
			t2 = space();
			button1 = element("button");
			button1.textContent = "Unlink";
			attr(input, "type", "text");
			attr(input, "placeholder", "Past your link, such as http://fouita.com");
			attr(input, "class", "bg-gray-100 border p-1 w-64 rounded outline-none\n        shadow-inner");
			attr(button0, "class", "ml-2 hover:bg-gray-300 px-3 rounded outline-none");
			attr(button1, "class", "hover:bg-gray-300 px-3 rounded outline-none");
			attr(div, "class", "absolute p-3 shadow-xl flex rounded bg-white -ml-24 mt-1 z-920");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			set_input_value(input, /*href*/ ctx[0]);
			append(div, t0);
			append(div, button0);
			append(div, t2);
			append(div, button1);

			if (!mounted) {
				dispose = [
					listen(input, "click", stop),
					listen(input, "focus", stop),
					listen(input, "input", /*input_input_handler*/ ctx[8]),
					listen(button0, "click", /*addLink*/ ctx[4]),
					listen(button1, "click", /*rmLink*/ ctx[5]),
					listen(div, "click", stop)
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*href*/ 1 && input.value !== /*href*/ ctx[0]) {
				set_input_value(input, /*href*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$6(ctx) {
	let div;
	let span1;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*show_link*/ ctx[1] && create_if_block$2(ctx);

	return {
		c() {
			div = element("div");
			span1 = element("span");
			span1.innerHTML = `<span class="border-b border-gray-400">Link</span>`;
			t1 = space();
			if (if_block) if_block.c();
			attr(span1, "class", "px-2 py-1");
			attr(div, "class", "relative");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span1);
			append(div, t1);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen(window, "click", /*hideLink*/ ctx[3]),
					listen(span1, "click", /*toggleLink*/ ctx[2]),
					listen(div, "mousedown", /*mousedown_handler*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*show_link*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function stop(e) {
	e.preventDefault();
	e.stopPropagation();
	return false;
}

function instance$3($$self, $$props, $$invalidate) {
	let { href } = $$props;
	let show_link = false;
	let { setLink } = $$props;

	function toggleLink(e) {
		$$invalidate(1, show_link = !show_link);
		stop(e);
	}

	function hideLink() {
		$$invalidate(1, show_link = false);
	}

	function addLink() {
		setLink("underline text-blue-500 link", href);
		hideLink();
	}

	function rmLink() {
		setLink("underline text-blue-500 link", null);
		hideLink();
	}

	function mousedown_handler(event) {
		bubble($$self, event);
	}

	function input_input_handler() {
		href = this.value;
		$$invalidate(0, href);
	}

	$$self.$$set = $$props => {
		if ("href" in $$props) $$invalidate(0, href = $$props.href);
		if ("setLink" in $$props) $$invalidate(6, setLink = $$props.setLink);
	};

	return [
		href,
		show_link,
		toggleLink,
		hideLink,
		addLink,
		rmLink,
		setLink,
		mousedown_handler,
		input_input_handler
	];
}

class LinkInput extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$6, safe_not_equal, { href: 0, setLink: 6 });
	}
}

/* src/Icons/CenterIcon.svelte generated by Svelte v3.24.1 */

function create_fragment$7(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M4 5C3.44772 5 3 5.44772 3 6C3 6.55228 3.44772 7 4 7H20C20.5523 7 21 6.55228 21 6C21 5.44772 20.5523 5 20 5H4Z");
			attr(path0, "fill", "currentColor");
			attr(path1, "d", "M4 13C3.44772 13 3 13.4477 3 14C3 14.5523 3.44772 15 4 15H20C20.5523 15 21 14.5523 21 14C21 13.4477 20.5523 13 20 13H4Z");
			attr(path1, "fill", "currentColor");
			attr(path2, "d", "M6 10C6 9.44772 6.44772 9 7 9H17C17.5523 9 18 9.44772 18 10C18 10.5523 17.5523 11 17 11H7C6.44772 11 6 10.5523 6 10Z");
			attr(path2, "fill", "currentColor");
			attr(path3, "d", "M7 17C6.44772 17 6 17.4477 6 18C6 18.5523 6.44772 19 7 19H17C17.5523 19 18 18.5523 18 18C18 17.4477 17.5523 17 17 17H7Z");
			attr(path3, "fill", "currentColor");
			attr(svg, "class", "w-5 h-5");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class CenterIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$7, safe_not_equal, {});
	}
}

/* src/Icons/LeftIcon.svelte generated by Svelte v3.24.1 */

function create_fragment$8(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M4 5C3.44772 5 3 5.44772 3 6C3 6.55228 3.44772 7 4 7H20C20.5523 7 21 6.55228 21 6C21 5.44772 20.5523 5 20 5H4Z");
			attr(path0, "fill", "currentColor");
			attr(path1, "d", "M4 9C3.44772 9 3 9.44772 3 10C3 10.5523 3.44772 11 4 11H12C12.5523 11 13 10.5523 13 10C13 9.44772 12.5523 9 12 9H4Z");
			attr(path1, "fill", "currentColor");
			attr(path2, "d", "M3 14C3 13.4477 3.44772 13 4 13H20C20.5523 13 21 13.4477 21 14C21 14.5523 20.5523 15 20 15H4C3.44772 15 3 14.5523 3 14Z");
			attr(path2, "fill", "currentColor");
			attr(path3, "d", "M4 17C3.44772 17 3 17.4477 3 18C3 18.5523 3.44772 19 4 19H12C12.5523 19 13 18.5523 13 18C13 17.4477 12.5523 17 12 17H4Z");
			attr(path3, "fill", "currentColor");
			attr(svg, "class", "w-5 h-5");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class LeftIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$8, safe_not_equal, {});
	}
}

/* src/Icons/RightIcon.svelte generated by Svelte v3.24.1 */

function create_fragment$9(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M20 5C20.5523 5 21 5.44772 21 6C21 6.55228 20.5523 7 20 7H4C3.44772 7 3 6.55228 3 6C3 5.44772 3.44772 5 4 5H20Z");
			attr(path0, "fill", "currentColor");
			attr(path1, "d", "M20 9C20.5523 9 21 9.44772 21 10C21 10.5523 20.5523 11 20 11H12C11.4477 11 11 10.5523 11 10C11 9.44772 11.4477 9 12 9H20Z");
			attr(path1, "fill", "currentColor");
			attr(path2, "d", "M21 14C21 13.4477 20.5523 13 20 13H4C3.44772 13 3 13.4477 3 14C3 14.5523 3.44772 15 4 15H20C20.5523 15 21 14.5523 21 14Z");
			attr(path2, "fill", "currentColor");
			attr(path3, "d", "M20 17C20.5523 17 21 17.4477 21 18C21 18.5523 20.5523 19 20 19H12C11.4477 19 11 18.5523 11 18C11 17.4477 11.4477 17 12 17H20Z");
			attr(path3, "fill", "currentColor");
			attr(svg, "class", "w-5 h-5");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class RightIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$9, safe_not_equal, {});
	}
}

/* src/Icons/JustifyIcon.svelte generated by Svelte v3.24.1 */

function create_fragment$a(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			attr(path0, "d", "M4 5C3.44772 5 3 5.44772 3 6C3 6.55228 3.44772 7 4 7H20C20.5523 7 21 6.55228 21 6C21 5.44772 20.5523 5 20 5H4Z");
			attr(path0, "fill", "currentColor");
			attr(path1, "d", "M4 9C3.44772 9 3 9.44772 3 10C3 10.5523 3.44772 11 4 11H20C20.5523 11 21 10.5523 21 10C21 9.44772 20.5523 9 20 9H4Z");
			attr(path1, "fill", "currentColor");
			attr(path2, "d", "M3 14C3 13.4477 3.44772 13 4 13H20C20.5523 13 21 13.4477 21 14C21 14.5523 20.5523 15 20 15H4C3.44772 15 3 14.5523 3 14Z");
			attr(path2, "fill", "currentColor");
			attr(path3, "d", "M4 17C3.44772 17 3 17.4477 3 18C3 18.5523 3.44772 19 4 19H20C20.5523 19 21 18.5523 21 18C21 17.4477 20.5523 17 20 17H4Z");
			attr(path3, "fill", "currentColor");
			attr(svg, "class", "w-5 h-5");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class JustifyIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$a, safe_not_equal, {});
	}
}

/* src/Icons/CheckIcon.svelte generated by Svelte v3.24.1 */

function create_fragment$b(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z");
			attr(path, "fill", "currentColor");
			attr(svg, "class", "w-4 h-4 text-gray-700");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class CheckIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$b, safe_not_equal, {});
	}
}

/* src/ToolBar/List.svelte generated by Svelte v3.24.1 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (19:3) {#if selected == elm.value}
function create_if_block$3(ctx) {
	let checkicon;
	let current;
	checkicon = new CheckIcon({});

	return {
		c() {
			create_component(checkicon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkicon, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(checkicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkicon, detaching);
		}
	};
}

// (17:1) {#each list as elm}
function create_each_block$1(ctx) {
	let div;
	let t0;
	let span;
	let t1_value = /*elm*/ ctx[5].label + "";
	let t1;
	let span_class_value;
	let t2;
	let current;
	let mounted;
	let dispose;
	let if_block = /*selected*/ ctx[0] == /*elm*/ ctx[5].value && create_if_block$3();

	function click_handler(...args) {
		return /*click_handler*/ ctx[3](/*elm*/ ctx[5], ...args);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			t2 = space();

			attr(span, "class", span_class_value = "" + ((/*selected*/ ctx[0] == /*elm*/ ctx[5].value
			? "ml-1"
			: "ml-5") + " pr-2"));

			attr(div, "class", "px-2 py-1 flex items-center hover:bg-gray-200 cursor-pointer");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t0);
			append(div, span);
			append(span, t1);
			append(div, t2);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*selected*/ ctx[0] == /*elm*/ ctx[5].value) {
				if (if_block) {
					if (dirty & /*selected, list*/ 3) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$3();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*list*/ 2) && t1_value !== (t1_value = /*elm*/ ctx[5].label + "")) set_data(t1, t1_value);

			if (!current || dirty & /*selected, list*/ 3 && span_class_value !== (span_class_value = "" + ((/*selected*/ ctx[0] == /*elm*/ ctx[5].value
			? "ml-1"
			: "ml-5") + " pr-2"))) {
				attr(span, "class", span_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$c(ctx) {
	let div;
	let current;
	let each_value = /*list*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "shadow-xl border-r border-l rounded mt-1 bg-white");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*select, list, selected*/ 7) {
				each_value = /*list*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let dispatch = createEventDispatcher();
	let { list = [] } = $$props;
	let { selected } = $$props;

	function select(e, val) {
		$$invalidate(0, selected = val);
		dispatch("select", selected);
		e.stopPropagation();
		e.preventDefault();
	}

	const click_handler = (elm, e) => select(e, elm.value);

	$$self.$$set = $$props => {
		if ("list" in $$props) $$invalidate(1, list = $$props.list);
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
	};

	return [selected, list, select, click_handler];
}

class List extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$c, safe_not_equal, { list: 1, selected: 0 });
	}
}

/* src/ToolBar/DropDown.svelte generated by Svelte v3.24.1 */

function fallback_block(ctx) {
	let t;

	return {
		c() {
			t = text("Click To show");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (54:1) {#if open}
function create_if_block$4(ctx) {
	let div;
	let list_1;
	let div_class_value;
	let current;

	list_1 = new List({
			props: {
				list: /*list*/ ctx[3],
				selected: /*selected*/ ctx[2]
			}
		});

	list_1.$on("select", /*select_handler*/ ctx[8]);

	return {
		c() {
			div = element("div");
			create_component(list_1.$$.fragment);
			attr(div, "class", div_class_value = "absolute -ml-1 z-920 " + /*klass*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(list_1, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const list_1_changes = {};
			if (dirty & /*list*/ 8) list_1_changes.list = /*list*/ ctx[3];
			if (dirty & /*selected*/ 4) list_1_changes.selected = /*selected*/ ctx[2];
			list_1.$set(list_1_changes);

			if (!current || dirty & /*klass*/ 2 && div_class_value !== (div_class_value = "absolute -ml-1 z-920 " + /*klass*/ ctx[1])) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(list_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(list_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(list_1);
		}
	};
}

function create_fragment$d(ctx) {
	let div1;
	let div0;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block();
	let if_block = /*open*/ ctx[0] && create_if_block$4(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			if (if_block) if_block.c();
			attr(div0, "class", "cursor-pointer flex h-full");
			attr(div1, "class", "relative");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div0, null);
			}

			append(div1, t);
			if (if_block) if_block.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "click", /*hideList*/ ctx[5]),
					listen(div0, "click", /*toggleList*/ ctx[4])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (/*open*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*open*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { class: klass = "" } = $$props;
	let { open = false } = $$props;
	let { selected } = $$props;

	let { list = [
		{ label: "none", value: "none" },
		{ label: "tight", value: "tight" },
		{ label: "snug", value: "snug" },
		{ label: "normal", value: "normal" },
		{ label: "relaxed", value: "relaxed" },
		{ label: "loose", value: "loose" }
	] } = $$props;

	function toggleList(e) {
		$$invalidate(0, open = !open);
		e.preventDefault();
		e.stopPropagation();
	}

	function hideList() {
		$$invalidate(0, open = false);
	}

	let { $$slots = {}, $$scope } = $$props;

	function select_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(1, klass = $$props.class);
		if ("open" in $$props) $$invalidate(0, open = $$props.open);
		if ("selected" in $$props) $$invalidate(2, selected = $$props.selected);
		if ("list" in $$props) $$invalidate(3, list = $$props.list);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [
		open,
		klass,
		selected,
		list,
		toggleList,
		hideList,
		$$scope,
		$$slots,
		select_handler
	];
}

class DropDown extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$d, safe_not_equal, { class: 1, open: 0, selected: 2, list: 3 });
	}
}

/* src/Icons/LineHeightIcon.svelte generated by Svelte v3.24.1 */

function create_fragment$e(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			attr(path0, "d", "M5.09668 6.99707H7.17358L4.17358 3.99707L1.17358 6.99707H3.09668V17.0031H1.15881L4.15881 20.0031L7.15881 17.0031H5.09668V6.99707Z");
			attr(path0, "fill", "currentColor");
			attr(path1, "d", "M22.8412 7H8.84119V5H22.8412V7Z");
			attr(path1, "fill", "currentColor");
			attr(path2, "d", "M22.8412 11H8.84119V9H22.8412V11Z");
			attr(path2, "fill", "currentColor");
			attr(path3, "d", "M8.84119 15H22.8412V13H8.84119V15Z");
			attr(path3, "fill", "currentColor");
			attr(path4, "d", "M22.8412 19H8.84119V17H22.8412V19Z");
			attr(path4, "fill", "currentColor");
			attr(svg, "class", "w-5 h-5 text-gray-700");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class LineHeightIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$e, safe_not_equal, {});
	}
}

/* src/ToolBar/Leading.svelte generated by Svelte v3.24.1 */

function create_default_slot(ctx) {
	let div;
	let lineheighticon;
	let current;
	lineheighticon = new LineHeightIcon({});

	return {
		c() {
			div = element("div");
			create_component(lineheighticon.$$.fragment);
			attr(div, "class", "pl-2 pr-3 py-1 h-full flex items-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(lineheighticon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(lineheighticon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(lineheighticon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(lineheighticon);
		}
	};
}

function create_fragment$f(ctx) {
	let div;
	let dropdown;
	let updating_open;
	let current;

	function dropdown_open_binding(value) {
		/*dropdown_open_binding*/ ctx[6].call(null, value);
	}

	let dropdown_props = {
		list: /*list*/ ctx[3],
		selected: /*selected*/ ctx[1],
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*open*/ ctx[0] !== void 0) {
		dropdown_props.open = /*open*/ ctx[0];
	}

	dropdown = new DropDown({ props: dropdown_props });
	binding_callbacks.push(() => bind(dropdown, "open", dropdown_open_binding));
	dropdown.$on("select", /*selectClass*/ ctx[2]);

	return {
		c() {
			div = element("div");
			create_component(dropdown.$$.fragment);
			attr(div, "class", "flex h-full");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(dropdown, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const dropdown_changes = {};
			if (dirty & /*selected*/ 2) dropdown_changes.selected = /*selected*/ ctx[1];

			if (dirty & /*$$scope*/ 256) {
				dropdown_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*open*/ 1) {
				updating_open = true;
				dropdown_changes.open = /*open*/ ctx[0];
				add_flush_callback(() => updating_open = false);
			}

			dropdown.$set(dropdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(dropdown);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { klass = "" } = $$props;
	let { setClass = "" } = $$props;
	let open = false;

	function selectClass(evt) {
		$$invalidate(0, open = false);
		setClass("leading-" + evt.detail);
	}

	let list = [
		{ label: "none", value: "none" },
		{ label: "tight", value: "tight" },
		{ label: "snug", value: "snug" },
		{ label: "normal", value: "normal" },
		{ label: "relaxed", value: "relaxed" },
		{ label: "loose", value: "loose" }
	];

	function dropdown_open_binding(value) {
		open = value;
		$$invalidate(0, open);
	}

	$$self.$$set = $$props => {
		if ("klass" in $$props) $$invalidate(4, klass = $$props.klass);
		if ("setClass" in $$props) $$invalidate(5, setClass = $$props.setClass);
	};

	let leading_class;
	let selected;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*klass*/ 16) {
			 $$invalidate(7, leading_class = klass.split(" ").find(c => c.startsWith("leading")) || "");
		}

		if ($$self.$$.dirty & /*leading_class*/ 128) {
			 $$invalidate(1, selected = leading_class.replace("leading-", ""));
		}
	};

	return [open, selected, selectClass, list, klass, setClass, dropdown_open_binding];
}

class Leading extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$f, safe_not_equal, { klass: 4, setClass: 5 });
	}
}

/* src/ToolBar/HeadingList.svelte generated by Svelte v3.24.1 */

function create_default_slot$1(ctx) {
	let div;
	let t0;
	let t1;
	let downicon;
	let current;
	downicon = new DownIcon({});

	return {
		c() {
			div = element("div");
			t0 = text(/*selected_label*/ ctx[2]);
			t1 = space();
			create_component(downicon.$$.fragment);
			attr(div, "class", "pl-2 pr-3 py-1 h-full flex items-center whitespace-nowrap flex-shrink-0");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
			mount_component(downicon, div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*selected_label*/ 4) set_data(t0, /*selected_label*/ ctx[2]);
		},
		i(local) {
			if (current) return;
			transition_in(downicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(downicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(downicon);
		}
	};
}

function create_fragment$g(ctx) {
	let div;
	let dropdown;
	let updating_open;
	let current;

	function dropdown_open_binding(value) {
		/*dropdown_open_binding*/ ctx[7].call(null, value);
	}

	let dropdown_props = {
		list: /*list*/ ctx[3],
		selected: /*selected_val*/ ctx[1],
		class: "w-32",
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	if (/*open*/ ctx[0] !== void 0) {
		dropdown_props.open = /*open*/ ctx[0];
	}

	dropdown = new DropDown({ props: dropdown_props });
	binding_callbacks.push(() => bind(dropdown, "open", dropdown_open_binding));
	dropdown.$on("select", /*selectClass*/ ctx[4]);

	return {
		c() {
			div = element("div");
			create_component(dropdown.$$.fragment);
			attr(div, "class", "flex h-full");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(dropdown, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const dropdown_changes = {};
			if (dirty & /*selected_val*/ 2) dropdown_changes.selected = /*selected_val*/ ctx[1];

			if (dirty & /*$$scope, selected_label*/ 2052) {
				dropdown_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*open*/ 1) {
				updating_open = true;
				dropdown_changes.open = /*open*/ ctx[0];
				add_flush_callback(() => updating_open = false);
			}

			dropdown.$set(dropdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(dropdown);
		}
	};
}

let code_class$1 = "code text-sm font-mono px-8 py-6 bg-gray-200";
let quote_class$1 = "quote text-xl border-l-4 border-gray-800 px-4 font-serif";

function instance$7($$self, $$props, $$invalidate) {
	let { setClass } = $$props;
	let { klass = "" } = $$props;

	let list = [
		{
			label: "Text Small",
			value: "md:text-sm text-sm"
		},
		{
			label: "Text",
			value: "md:text-base text-base"
		},
		{ label: "Code", value: code_class$1 },
		{ label: "Quote", value: quote_class$1 },
		{
			label: "Heading 1",
			value: "md:text-6xl text-4xl"
		},
		{
			label: "Heading 2",
			value: "md:text-5xl text-3xl"
		},
		{
			label: "Heading 3",
			value: "md:text-4xl text-2xl"
		},
		{
			label: "Heading 4",
			value: "md:text-3xl text-xl"
		},
		{
			label: "Heading 5",
			value: "md:text-2xl text-xl"
		},
		{
			label: "Heading 6",
			value: "md:text-xl text-lg"
		}
	];

	function inList() {
		for (let v of list) {
			if (~klass.indexOf(v.value)) return v.value;
		}

		return false;
	}

	let open = false;

	function selectClass(evt) {
		$$invalidate(1, selected_val = evt.detail);
		$$invalidate(0, open = false);
		setClass(evt.detail);
	}

	function dropdown_open_binding(value) {
		open = value;
		$$invalidate(0, open);
	}

	$$self.$$set = $$props => {
		if ("setClass" in $$props) $$invalidate(5, setClass = $$props.setClass);
		if ("klass" in $$props) $$invalidate(6, klass = $$props.klass);
	};

	let text_class;
	let selected_val;
	let selected;
	let selected_label;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*klass*/ 64) {
			 $$invalidate(8, text_class = klass.includes("code") && code_class$1 || klass.includes("quote") && quote_class$1 || inList() || "");
		}

		if ($$self.$$.dirty & /*text_class*/ 256) {
			 $$invalidate(1, selected_val = text_class);
		}

		if ($$self.$$.dirty & /*selected_val*/ 2) {
			 $$invalidate(9, selected = list.find(e => e.value == selected_val));
		}

		if ($$self.$$.dirty & /*selected*/ 512) {
			 $$invalidate(2, selected_label = selected && selected.label || "Text");
		}
	};

	return [
		open,
		selected_val,
		selected_label,
		list,
		selectClass,
		setClass,
		klass,
		dropdown_open_binding
	];
}

class HeadingList extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$g, safe_not_equal, { setClass: 5, klass: 6 });
	}
}

/* src/ToolBar/ToolBar.svelte generated by Svelte v3.24.1 */

function create_fragment$h(ctx) {
	let div15;
	let div14;
	let div0;
	let headinglist;
	let t0;
	let div1;
	let t1;
	let div1_class_value;
	let t2;
	let div2;
	let t3;
	let div2_class_value;
	let t4;
	let div3;
	let t5;
	let div3_class_value;
	let t6;
	let div4;
	let t7;
	let div4_class_value;
	let t8;
	let div5;
	let codeicon;
	let div5_class_value;
	let t9;
	let div6;
	let linkinput;
	let div6_class_value;
	let t10;
	let div7;
	let colorpicker0;
	let t11;
	let div8;
	let colorpicker1;
	let t12;
	let div9;
	let justifyicon;
	let div9_class_value;
	let t13;
	let div10;
	let lefticon;
	let div10_class_value;
	let t14;
	let div11;
	let centericon;
	let div11_class_value;
	let t15;
	let div12;
	let righticon;
	let div12_class_value;
	let t16;
	let div13;
	let leading;
	let setPosition_action;
	let current;
	let mounted;
	let dispose;

	headinglist = new HeadingList({
			props: {
				setClass: /*setGClass*/ ctx[3],
				klass: /*g_classes*/ ctx[1]
			}
		});

	codeicon = new CodeIcon({});

	linkinput = new LinkInput({
			props: {
				setLink: /*setClass*/ ctx[2],
				href: /*href*/ ctx[4]
			}
		});

	linkinput.$on("close", /*close*/ ctx[7]);

	colorpicker0 = new ColorPicker({
			props: {
				setClass: /*setClass*/ ctx[2],
				klass: /*classes*/ ctx[0]
			}
		});

	colorpicker1 = new ColorPicker({
			props: {
				txt: "bg",
				setClass: /*setClass*/ ctx[2],
				klass: /*classes*/ ctx[0]
			}
		});

	justifyicon = new JustifyIcon({});
	lefticon = new LeftIcon({});
	centericon = new CenterIcon({});
	righticon = new RightIcon({});

	leading = new Leading({
			props: {
				setClass: /*setGClass*/ ctx[3],
				klass: /*g_classes*/ ctx[1]
			}
		});

	return {
		c() {
			div15 = element("div");
			div14 = element("div");
			div0 = element("div");
			create_component(headinglist.$$.fragment);
			t0 = space();
			div1 = element("div");
			t1 = text("B");
			t2 = space();
			div2 = element("div");
			t3 = text("i");
			t4 = space();
			div3 = element("div");
			t5 = text("U");
			t6 = space();
			div4 = element("div");
			t7 = text("S");
			t8 = space();
			div5 = element("div");
			create_component(codeicon.$$.fragment);
			t9 = space();
			div6 = element("div");
			create_component(linkinput.$$.fragment);
			t10 = space();
			div7 = element("div");
			create_component(colorpicker0.$$.fragment);
			t11 = space();
			div8 = element("div");
			create_component(colorpicker1.$$.fragment);
			t12 = space();
			div9 = element("div");
			create_component(justifyicon.$$.fragment);
			t13 = space();
			div10 = element("div");
			create_component(lefticon.$$.fragment);
			t14 = space();
			div11 = element("div");
			create_component(centericon.$$.fragment);
			t15 = space();
			div12 = element("div");
			create_component(righticon.$$.fragment);
			t16 = space();
			div13 = element("div");
			create_component(leading.$$.fragment);
			attr(div0, "class", "border-r");
			attr(div1, "class", div1_class_value = "px-2 cursor-pointer select-none " + (/*e_classes*/ ctx[5].bold ? "text-blue-600" : "") + " font-medium hover:bg-gray-200 py-1");
			attr(div2, "class", div2_class_value = "px-3 cursor-pointer select-none " + (/*e_classes*/ ctx[5].italic ? "text-blue-600" : "") + " italic hover:bg-gray-200 py-1");
			attr(div3, "class", div3_class_value = "px-2 cursor-pointer select-none " + (/*e_classes*/ ctx[5].underline ? "text-blue-600" : "") + " underline hover:bg-gray-200 py-1");
			attr(div4, "class", div4_class_value = "px-2 cursor-pointer select-none " + (/*e_classes*/ ctx[5].linethrough ? "text-blue-600" : "") + " line-through hover:bg-gray-200 py-1");
			attr(div5, "class", div5_class_value = "px-2 cursor-pointer select-none " + (/*e_classes*/ ctx[5].code ? "text-blue-600" : "") + " line-through hover:bg-gray-200 py-2");
			attr(div6, "class", div6_class_value = "" + ((/*e_classes*/ ctx[5].link ? "text-blue-600" : "") + " cursor-pointer select-none hover:bg-gray-200 text-sm border-r"));
			attr(div7, "class", "pl-1 cursor-pointer select-none hover:bg-gray-200 py-1 ");
			attr(div8, "class", "px-1 cursor-pointer select-none hover:bg-gray-200 border-r h-full flex items-center");

			attr(div9, "class", div9_class_value = "px-2 " + (/*e_classes*/ ctx[5].justify
			? "text-blue-600"
			: "text-gray-700") + " cursor-pointer select-none hover:bg-gray-200 py-1 h-full flex items-center");

			attr(div10, "class", div10_class_value = "px-2 " + (/*e_classes*/ ctx[5].left
			? "text-blue-600"
			: "text-gray-700") + " cursor-pointer select-none hover:bg-gray-200 py-1 h-full flex items-center");

			attr(div11, "class", div11_class_value = "px-2 " + (/*e_classes*/ ctx[5].center
			? "text-blue-600"
			: "text-gray-700") + " cursor-pointer select-none hover:bg-gray-200 py-1 h-full flex items-center");

			attr(div12, "class", div12_class_value = "px-2 " + (/*e_classes*/ ctx[5].right
			? "text-blue-600"
			: "text-gray-700") + " cursor-pointer select-none hover:bg-gray-200 py-1 h-full flex items-center border-r");

			attr(div13, "class", "cursor-pointer select-none hover:bg-gray-200 h-full flex items-center");
			attr(div14, "class", "rounded flex items-center shadow-lg border border-gray-200  text-gray-700");
			attr(div15, "class", "flex fixed font-normal -mt-6 shadow bg-white z-950 text-base rounded");
		},
		m(target, anchor) {
			insert(target, div15, anchor);
			append(div15, div14);
			append(div14, div0);
			mount_component(headinglist, div0, null);
			append(div14, t0);
			append(div14, div1);
			append(div1, t1);
			append(div14, t2);
			append(div14, div2);
			append(div2, t3);
			append(div14, t4);
			append(div14, div3);
			append(div3, t5);
			append(div14, t6);
			append(div14, div4);
			append(div4, t7);
			append(div14, t8);
			append(div14, div5);
			mount_component(codeicon, div5, null);
			append(div14, t9);
			append(div14, div6);
			mount_component(linkinput, div6, null);
			append(div14, t10);
			append(div14, div7);
			mount_component(colorpicker0, div7, null);
			append(div14, t11);
			append(div14, div8);
			mount_component(colorpicker1, div8, null);
			append(div14, t12);
			append(div14, div9);
			mount_component(justifyicon, div9, null);
			append(div14, t13);
			append(div14, div10);
			mount_component(lefticon, div10, null);
			append(div14, t14);
			append(div14, div11);
			mount_component(centericon, div11, null);
			append(div14, t15);
			append(div14, div12);
			mount_component(righticon, div12, null);
			append(div14, t16);
			append(div14, div13);
			mount_component(leading, div13, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "mousedown", /*toggleBold*/ ctx[10]),
					listen(div2, "mousedown", /*mousedown_handler_1*/ ctx[15]),
					listen(div3, "mousedown", /*mousedown_handler_2*/ ctx[16]),
					listen(div4, "mousedown", /*mousedown_handler_3*/ ctx[17]),
					listen(div5, "mousedown", /*mousedown_handler_4*/ ctx[18]),
					listen(div9, "mousedown", /*mousedown_handler_5*/ ctx[19]),
					listen(div10, "mousedown", /*mousedown_handler_6*/ ctx[20]),
					listen(div11, "mousedown", /*mousedown_handler_7*/ ctx[21]),
					listen(div12, "mousedown", /*mousedown_handler_8*/ ctx[22]),
					action_destroyer(setPosition_action = /*setPosition*/ ctx[6].call(null, div15)),
					listen(div15, "mousedown", stop_propagation(/*mousedown_handler*/ ctx[14]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const headinglist_changes = {};
			if (dirty & /*setGClass*/ 8) headinglist_changes.setClass = /*setGClass*/ ctx[3];
			if (dirty & /*g_classes*/ 2) headinglist_changes.klass = /*g_classes*/ ctx[1];
			headinglist.$set(headinglist_changes);

			if (!current || dirty & /*e_classes*/ 32 && div1_class_value !== (div1_class_value = "px-2 cursor-pointer select-none " + (/*e_classes*/ ctx[5].bold ? "text-blue-600" : "") + " font-medium hover:bg-gray-200 py-1")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*e_classes*/ 32 && div2_class_value !== (div2_class_value = "px-3 cursor-pointer select-none " + (/*e_classes*/ ctx[5].italic ? "text-blue-600" : "") + " italic hover:bg-gray-200 py-1")) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty & /*e_classes*/ 32 && div3_class_value !== (div3_class_value = "px-2 cursor-pointer select-none " + (/*e_classes*/ ctx[5].underline ? "text-blue-600" : "") + " underline hover:bg-gray-200 py-1")) {
				attr(div3, "class", div3_class_value);
			}

			if (!current || dirty & /*e_classes*/ 32 && div4_class_value !== (div4_class_value = "px-2 cursor-pointer select-none " + (/*e_classes*/ ctx[5].linethrough ? "text-blue-600" : "") + " line-through hover:bg-gray-200 py-1")) {
				attr(div4, "class", div4_class_value);
			}

			if (!current || dirty & /*e_classes*/ 32 && div5_class_value !== (div5_class_value = "px-2 cursor-pointer select-none " + (/*e_classes*/ ctx[5].code ? "text-blue-600" : "") + " line-through hover:bg-gray-200 py-2")) {
				attr(div5, "class", div5_class_value);
			}

			const linkinput_changes = {};
			if (dirty & /*setClass*/ 4) linkinput_changes.setLink = /*setClass*/ ctx[2];
			if (dirty & /*href*/ 16) linkinput_changes.href = /*href*/ ctx[4];
			linkinput.$set(linkinput_changes);

			if (!current || dirty & /*e_classes*/ 32 && div6_class_value !== (div6_class_value = "" + ((/*e_classes*/ ctx[5].link ? "text-blue-600" : "") + " cursor-pointer select-none hover:bg-gray-200 text-sm border-r"))) {
				attr(div6, "class", div6_class_value);
			}

			const colorpicker0_changes = {};
			if (dirty & /*setClass*/ 4) colorpicker0_changes.setClass = /*setClass*/ ctx[2];
			if (dirty & /*classes*/ 1) colorpicker0_changes.klass = /*classes*/ ctx[0];
			colorpicker0.$set(colorpicker0_changes);
			const colorpicker1_changes = {};
			if (dirty & /*setClass*/ 4) colorpicker1_changes.setClass = /*setClass*/ ctx[2];
			if (dirty & /*classes*/ 1) colorpicker1_changes.klass = /*classes*/ ctx[0];
			colorpicker1.$set(colorpicker1_changes);

			if (!current || dirty & /*e_classes*/ 32 && div9_class_value !== (div9_class_value = "px-2 " + (/*e_classes*/ ctx[5].justify
			? "text-blue-600"
			: "text-gray-700") + " cursor-pointer select-none hover:bg-gray-200 py-1 h-full flex items-center")) {
				attr(div9, "class", div9_class_value);
			}

			if (!current || dirty & /*e_classes*/ 32 && div10_class_value !== (div10_class_value = "px-2 " + (/*e_classes*/ ctx[5].left
			? "text-blue-600"
			: "text-gray-700") + " cursor-pointer select-none hover:bg-gray-200 py-1 h-full flex items-center")) {
				attr(div10, "class", div10_class_value);
			}

			if (!current || dirty & /*e_classes*/ 32 && div11_class_value !== (div11_class_value = "px-2 " + (/*e_classes*/ ctx[5].center
			? "text-blue-600"
			: "text-gray-700") + " cursor-pointer select-none hover:bg-gray-200 py-1 h-full flex items-center")) {
				attr(div11, "class", div11_class_value);
			}

			if (!current || dirty & /*e_classes*/ 32 && div12_class_value !== (div12_class_value = "px-2 " + (/*e_classes*/ ctx[5].right
			? "text-blue-600"
			: "text-gray-700") + " cursor-pointer select-none hover:bg-gray-200 py-1 h-full flex items-center border-r")) {
				attr(div12, "class", div12_class_value);
			}

			const leading_changes = {};
			if (dirty & /*setGClass*/ 8) leading_changes.setClass = /*setGClass*/ ctx[3];
			if (dirty & /*g_classes*/ 2) leading_changes.klass = /*g_classes*/ ctx[1];
			leading.$set(leading_changes);
		},
		i(local) {
			if (current) return;
			transition_in(headinglist.$$.fragment, local);
			transition_in(codeicon.$$.fragment, local);
			transition_in(linkinput.$$.fragment, local);
			transition_in(colorpicker0.$$.fragment, local);
			transition_in(colorpicker1.$$.fragment, local);
			transition_in(justifyicon.$$.fragment, local);
			transition_in(lefticon.$$.fragment, local);
			transition_in(centericon.$$.fragment, local);
			transition_in(righticon.$$.fragment, local);
			transition_in(leading.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(headinglist.$$.fragment, local);
			transition_out(codeicon.$$.fragment, local);
			transition_out(linkinput.$$.fragment, local);
			transition_out(colorpicker0.$$.fragment, local);
			transition_out(colorpicker1.$$.fragment, local);
			transition_out(justifyicon.$$.fragment, local);
			transition_out(lefticon.$$.fragment, local);
			transition_out(centericon.$$.fragment, local);
			transition_out(righticon.$$.fragment, local);
			transition_out(leading.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div15);
			destroy_component(headinglist);
			destroy_component(codeicon);
			destroy_component(linkinput);
			destroy_component(colorpicker0);
			destroy_component(colorpicker1);
			destroy_component(justifyicon);
			destroy_component(lefticon);
			destroy_component(centericon);
			destroy_component(righticon);
			destroy_component(leading);
			mounted = false;
			run_all(dispose);
		}
	};
}

const reg_font$1 = /font\-(thin|normal|semibold|bold|black)/;

// duplicated!! 
const reg_position$1 = /^text\-(left|right|center)/;

function firstParentRelative(n) {
	// Make element absolute if you want to restore this
	// while(n.parentNode && n.parentNode.tagName){
	// 	n = n.parentNode
	// 	if(window.getComputedStyle(n).getPropertyValue('position').toLowerCase() == 'relative'){
	// 		return n.getBoundingClientRect()
	// 	}
	// }
	// return {top: -window.scrollY, left: 0}
	return { top: 0, left: 0 };
}

// duplicated in contenteditor (TO UPDATE!)
function replaceGClass(klass, reg, gklass) {
	let classes = gklass.split(" ");
	let s_index = classes.findIndex(c => reg.test(c));
	let selected_class = ~s_index ? classes[s_index] : "";

	if (selected_class) {
		gklass = gklass.replace(selected_class, "").trim();
	}

	gklass = gklass.split(" ").concat([klass]).join(" ");
	return gklass;
}

function instance$8($$self, $$props, $$invalidate) {
	let { setClass } = $$props;
	let { setGClass } = $$props;
	let { classes } = $$props;
	let { g_classes } = $$props;
	let { href } = $$props;
	let { base_node } = $$props;
	let dispatch = createEventDispatcher();
	let { mouseX } = $$props;

	function setPosition(node) {
		if (!base_node) return;

		let elm = base_node.parentNode.tagName == "DIV"
		? base_node
		: base_node.parentNode;

		let rect = elm.parentNode.getBoundingClientRect();
		let posY = rect.top - 10;

		if (elm.previousElementSibling) {
			let ch_nodes = [...elm.parentNode.childNodes];
			let siblings = ch_nodes.slice(0, ch_nodes.indexOf(elm) + 1);
			let br = siblings.reverse().find(elm => elm.tagName == "BR");

			if (br) {
				rect = br.getBoundingClientRect();
				posY = rect.top ? rect.top : posY;
			}
		}

		let rel_rect = firstParentRelative();
		let pos_top = posY - rel_rect.top;
		if (posY < 30) pos_top = 30;
		node.style.top = `${pos_top}px`;
		$$invalidate(12, mouseX = mouseX || 10);
		let mx = mouseX - node.offsetWidth / 2;
		mx = mx > 0 ? mx : 10;

		mx = mouseX + node.offsetWidth / 2 < window.innerWidth
		? mx
		: window.innerWidth - node.offsetWidth;

		node.style.left = `${mx - rel_rect.left}px`;
	}

	function close() {
		dispatch("close");
	}

	function cexist(klass) {
		return classes.includes(klass);
	}

	function cgexist(klass) {
		return g_classes.includes(klass);
	}

	function cregexist(reg) {
		return reg.test(classes);
	}

	const STYLE = {
		BOLD: "font-bold",
		ITALIC: "italic",
		UNDERLINE: "underline",
		LINETHROUGH: "line-through",
		CODE: "font-mono px-2 border border-gray-200",
		LINK: "underline text-blue-500 link",
		CENTER: "text-center",
		LEFT: "text-left",
		RIGHT: "text-right",
		JUSTIFY: "text-justify"
	};

	let e_classes = {};

	function initEClasses() {
		$$invalidate(5, e_classes = {
			bold: cregexist(reg_font$1),
			italic: cexist(STYLE.ITALIC),
			underline: cexist(STYLE.UNDERLINE),
			linethrough: cexist(STYLE.LINETHROUGH),
			code: cexist(STYLE.CODE),
			link: cexist(STYLE.LINK),
			justify: cgexist(STYLE.JUSTIFY),
			center: cgexist(STYLE.CENTER),
			left: cgexist(STYLE.LEFT),
			right: cgexist(STYLE.RIGHT)
		});
	}

	initEClasses();

	function toggle(klass) {
		setClass(klass);

		if (!classes.includes(klass)) {
			$$invalidate(0, classes = classes.split(" ").concat([klass]).join(" "));
		} else {
			let n_classes = classes.split(" ");
			n_classes.splice(n_classes.indexOf(klass), 1);
			$$invalidate(0, classes = n_classes.join(" "));
		}

		initEClasses();
	}

	function toggleBold() {
		const fonts = ["thin", "normal", "semibold", "bold", "black"];
		let included = false;

		for (let i = 0; i < fonts.length; i++) {
			if (classes.includes(fonts[i])) {
				included = true;

				if (i + 1 < fonts.length) {
					$$invalidate(0, classes = classes.replace("font-" + fonts[i], "font-" + fonts[i + 1]).trim());
					setClass("font-" + fonts[i + 1]);
				} else {
					$$invalidate(0, classes = classes.replace("font-" + fonts[i], "font-" + fonts[0]).trim());
					setClass("font-" + fonts[0]);
				}

				break;
			}
		}

		if (!included) {
			$$invalidate(0, classes = classes.split(" ").concat(["font-bold"]).join(" ").trim());
			setClass("font-bold");
		}

		initEClasses();
	}

	function toggleG(klass) {
		setGClass(klass);

		if (reg_position$1.test(klass)) {
			$$invalidate(1, g_classes = replaceGClass(klass, reg_position$1, g_classes));
		} else if (!g_classes.includes(klass)) {
			$$invalidate(1, g_classes = g_classes.split(" ").concat([klass]).join(" "));
		} else {
			let n_classes = g_classes.split(" ");
			n_classes.splice(n_classes.indexOf(klass), 1);
			$$invalidate(1, g_classes = n_classes.join(" "));
		}

		initEClasses();
	}

	function mousedown_handler(event) {
		bubble($$self, event);
	}

	const mousedown_handler_1 = () => toggle(STYLE.ITALIC);
	const mousedown_handler_2 = () => toggle(STYLE.UNDERLINE);
	const mousedown_handler_3 = () => toggle(STYLE.LINETHROUGH);
	const mousedown_handler_4 = () => toggle(STYLE.CODE);
	const mousedown_handler_5 = () => toggleG(STYLE.JUSTIFY);
	const mousedown_handler_6 = () => toggleG(STYLE.LEFT);
	const mousedown_handler_7 = () => toggleG(STYLE.CENTER);
	const mousedown_handler_8 = () => toggleG(STYLE.RIGHT);

	$$self.$$set = $$props => {
		if ("setClass" in $$props) $$invalidate(2, setClass = $$props.setClass);
		if ("setGClass" in $$props) $$invalidate(3, setGClass = $$props.setGClass);
		if ("classes" in $$props) $$invalidate(0, classes = $$props.classes);
		if ("g_classes" in $$props) $$invalidate(1, g_classes = $$props.g_classes);
		if ("href" in $$props) $$invalidate(4, href = $$props.href);
		if ("base_node" in $$props) $$invalidate(13, base_node = $$props.base_node);
		if ("mouseX" in $$props) $$invalidate(12, mouseX = $$props.mouseX);
	};

	return [
		classes,
		g_classes,
		setClass,
		setGClass,
		href,
		e_classes,
		setPosition,
		close,
		STYLE,
		toggle,
		toggleBold,
		toggleG,
		mouseX,
		base_node,
		mousedown_handler,
		mousedown_handler_1,
		mousedown_handler_2,
		mousedown_handler_3,
		mousedown_handler_4,
		mousedown_handler_5,
		mousedown_handler_6,
		mousedown_handler_7,
		mousedown_handler_8
	];
}

class ToolBar extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$8, create_fragment$h, safe_not_equal, {
			setClass: 2,
			setGClass: 3,
			classes: 0,
			g_classes: 1,
			href: 4,
			base_node: 13,
			mouseX: 12
		});
	}
}

/* src/ToolBar/MediaInput.svelte generated by Svelte v3.24.1 */

function create_if_block_2$1(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "type", "text");
			attr(input, "placeholder", "Image src");
			attr(input, "class", "bg-gray-100 text-sm font-mono mb-2 border p-1 w-64 rounded-sm outline-none shadow-inner");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*src*/ ctx[1]);

			if (!mounted) {
				dispose = listen(input, "input", /*input_input_handler*/ ctx[13]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*src*/ 2 && input.value !== /*src*/ ctx[1]) {
				set_input_value(input, /*src*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

// (81:4) {#if media_type == "IMG"}
function create_if_block_1$1(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "type", "text");
			attr(input, "placeholder", "Image alt");
			attr(input, "class", "bg-gray-100 text-sm font-mono mb-2 border p-1 w-64 rounded-sm outline-none shadow-inner");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*alt*/ ctx[0]);

			if (!mounted) {
				dispose = listen(input, "input", /*input_input_handler_1*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*alt*/ 1 && input.value !== /*alt*/ ctx[0]) {
				set_input_value(input, /*alt*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

// (88:4) {#if media_type == "VIDEO"}
function create_if_block$5(ctx) {
	let div;
	let label0;
	let input0;
	let t0;
	let t1;
	let label1;
	let input1;
	let t2;
	let t3;
	let label2;
	let input2;
	let t4;
	let t5;
	let label3;
	let input3;
	let t6;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			label0 = element("label");
			input0 = element("input");
			t0 = text("\n                Autoplay");
			t1 = space();
			label1 = element("label");
			input1 = element("input");
			t2 = text("\n                Muted");
			t3 = space();
			label2 = element("label");
			input2 = element("input");
			t4 = text("\n                Loop");
			t5 = space();
			label3 = element("label");
			input3 = element("input");
			t6 = text("\n                Controls");
			attr(input0, "class", "mr-2");
			attr(input0, "type", "checkbox");
			attr(label0, "class", "flex items-center");
			attr(input1, "class", "mr-2");
			attr(input1, "type", "checkbox");
			attr(label1, "class", "flex items-center");
			attr(input2, "class", "mr-2");
			attr(input2, "type", "checkbox");
			attr(label2, "class", "flex items-center");
			attr(input3, "class", "mr-2");
			attr(input3, "type", "checkbox");
			attr(label3, "class", "flex items-center");
			attr(div, "class", "text-xs my-2");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label0);
			append(label0, input0);
			input0.checked = /*opts*/ ctx[2].autoplay;
			append(label0, t0);
			append(div, t1);
			append(div, label1);
			append(label1, input1);
			input1.checked = /*opts*/ ctx[2].muted;
			append(label1, t2);
			append(div, t3);
			append(div, label2);
			append(label2, input2);
			input2.checked = /*opts*/ ctx[2].loop;
			append(label2, t4);
			append(div, t5);
			append(div, label3);
			append(label3, input3);
			input3.checked = /*opts*/ ctx[2].controls;
			append(label3, t6);

			if (!mounted) {
				dispose = [
					listen(input0, "change", /*input0_change_handler*/ ctx[16]),
					listen(input1, "change", /*input1_change_handler*/ ctx[17]),
					listen(input2, "change", /*input2_change_handler*/ ctx[18]),
					listen(input3, "change", /*input3_change_handler*/ ctx[19])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*opts*/ 4) {
				input0.checked = /*opts*/ ctx[2].autoplay;
			}

			if (dirty & /*opts*/ 4) {
				input1.checked = /*opts*/ ctx[2].muted;
			}

			if (dirty & /*opts*/ 4) {
				input2.checked = /*opts*/ ctx[2].loop;
			}

			if (dirty & /*opts*/ 4) {
				input3.checked = /*opts*/ ctx[2].controls;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$i(ctx) {
	let div1;
	let t0;
	let t1;
	let input;
	let t2;
	let t3;
	let div0;
	let button0;
	let t5;
	let button1;
	let t7;
	let button2;
	let setPosition_action;
	let mounted;
	let dispose;
	let if_block0 = /*src*/ ctx[1] && create_if_block_2$1(ctx);
	let if_block1 = /*media_type*/ ctx[5] == "IMG" && create_if_block_1$1(ctx);
	let if_block2 = /*media_type*/ ctx[5] == "VIDEO" && create_if_block$5(ctx);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			input = element("input");
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			div0 = element("div");
			button0 = element("button");
			button0.textContent = "Cancel";
			t5 = space();
			button1 = element("button");
			button1.textContent = "Delete";
			t7 = space();
			button2 = element("button");
			button2.textContent = "Update";
			attr(input, "type", "text");
			attr(input, "placeholder", "Class");
			attr(input, "class", "bg-gray-100 text-sm font-mono border p-1 w-64 rounded-sm outline-none shadow-inner");
			attr(button0, "class", "hover:bg-gray-300 px-3 rounded-sm outline-none text-xs py-1");
			attr(button1, "class", "hover:bg-red-700 px-3 rounded-sm outline-none mx-2 bg-red-600 text-red-100 text-xs py-1");
			attr(button2, "class", "ml-2 hover:bg-blue-700 bg-blue-600 text-blue-100 px-3 rounded-sm outline-none text-xs py-1");
			attr(div0, "class", "flex items-center flex-row-reverse mt-2");
			attr(div1, "class", "absolute -mt-6 p-3 shadow-xl flex flex-col rounded bg-white z-940");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t1);
			append(div1, input);
			set_input_value(input, /*klass*/ ctx[3]);
			append(div1, t2);
			if (if_block2) if_block2.m(div1, null);
			append(div1, t3);
			append(div1, div0);
			append(div0, button0);
			append(div0, t5);
			append(div0, button1);
			append(div0, t7);
			append(div0, button2);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_2*/ ctx[15]),
					listen(button0, "click", /*cancelMedia*/ ctx[7]),
					listen(button1, "click", function () {
						if (is_function(/*delMedia*/ ctx[4])) /*delMedia*/ ctx[4].apply(this, arguments);
					}),
					listen(button2, "click", /*addMedia*/ ctx[6]),
					action_destroyer(setPosition_action = /*setPosition*/ ctx[8].call(null, div1))
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (/*src*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*media_type*/ ctx[5] == "IMG") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					if_block1.m(div1, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*klass*/ 8 && input.value !== /*klass*/ ctx[3]) {
				set_input_value(input, /*klass*/ ctx[3]);
			}

			if (/*media_type*/ ctx[5] == "VIDEO") {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$5(ctx);
					if_block2.c();
					if_block2.m(div1, t3);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function firstParentRelative$1(n) {
	while (n.parentNode && n.parentNode.tagName) {
		n = n.parentNode;

		if (window.getComputedStyle(n).getPropertyValue("position").toLowerCase() == "relative") {
			return n.getBoundingClientRect();
		}
	}

	return { top: -window.scrollY, left: 0 };
}

function instance$9($$self, $$props, $$invalidate) {
	let { alt } = $$props;
	let { src } = $$props;
	let { opts } = $$props;
	let { klass = "" } = $$props;
	let { setMedia } = $$props;
	let { delMedia } = $$props;
	let { cancel } = $$props;
	let { media_type } = $$props;

	async function addMedia() {
		let is_img = await Util.testImgUrl(src.trim());
		let is_video = Util.testVideoUrl(src.trim());
		let iframe_vid = Util.parseYouTube(src.trim()) || Util.parseVimeo(src.trim());

		if (is_img || is_video || iframe_vid) {
			setMedia({
				src: iframe_vid || src,
				klass,
				alt,
				opts,
				media_type: is_img
				? "IMG"
				: is_video ? "VIDEO" : iframe_vid ? "IFRAME" : "AUDIO"
			});
		}
	}

	function cancelMedia() {
		cancel();
	}

	let { mouseX } = $$props;
	let { base_node } = $$props;

	function setPosition(node) {
		if (!base_node) return;

		let elm = base_node.parentNode.tagName == "DIV"
		? base_node
		: base_node.parentNode;

		let rect = elm.parentNode.getBoundingClientRect();
		let posY = rect.top;

		if (elm.previousElementSibling) {
			let ch_nodes = [...elm.parentNode.childNodes];
			let siblings = ch_nodes.slice(0, ch_nodes.indexOf(elm) + 1);
			let br = siblings.reverse().find(elm => elm.tagName == "BR");

			if (br) {
				rect = br.getBoundingClientRect();
				posY = rect.top ? rect.top : posY;
			}
		}

		// node.style.top = `${posY+window.scrollY}px`
		let rel_rect = firstParentRelative$1(node);

		let pos_top = posY - rel_rect.top;
		if (posY < 30) pos_top = 30;
		node.style.top = `${pos_top}px`;
		$$invalidate(9, mouseX = mouseX || 10);
		let mx = mouseX - node.offsetWidth / 2;
		mx = mx > 0 ? mx : 10;

		mx = mouseX + node.offsetWidth / 2 < window.innerWidth
		? mx
		: window.innerWidth - node.offsetWidth;

		node.style.left = `${mx - rel_rect.left}px`;
	}

	function input_input_handler() {
		src = this.value;
		$$invalidate(1, src);
	}

	function input_input_handler_1() {
		alt = this.value;
		$$invalidate(0, alt);
	}

	function input_input_handler_2() {
		klass = this.value;
		$$invalidate(3, klass);
	}

	function input0_change_handler() {
		opts.autoplay = this.checked;
		$$invalidate(2, opts);
	}

	function input1_change_handler() {
		opts.muted = this.checked;
		$$invalidate(2, opts);
	}

	function input2_change_handler() {
		opts.loop = this.checked;
		$$invalidate(2, opts);
	}

	function input3_change_handler() {
		opts.controls = this.checked;
		$$invalidate(2, opts);
	}

	$$self.$$set = $$props => {
		if ("alt" in $$props) $$invalidate(0, alt = $$props.alt);
		if ("src" in $$props) $$invalidate(1, src = $$props.src);
		if ("opts" in $$props) $$invalidate(2, opts = $$props.opts);
		if ("klass" in $$props) $$invalidate(3, klass = $$props.klass);
		if ("setMedia" in $$props) $$invalidate(10, setMedia = $$props.setMedia);
		if ("delMedia" in $$props) $$invalidate(4, delMedia = $$props.delMedia);
		if ("cancel" in $$props) $$invalidate(11, cancel = $$props.cancel);
		if ("media_type" in $$props) $$invalidate(5, media_type = $$props.media_type);
		if ("mouseX" in $$props) $$invalidate(9, mouseX = $$props.mouseX);
		if ("base_node" in $$props) $$invalidate(12, base_node = $$props.base_node);
	};

	return [
		alt,
		src,
		opts,
		klass,
		delMedia,
		media_type,
		addMedia,
		cancelMedia,
		setPosition,
		mouseX,
		setMedia,
		cancel,
		base_node,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input0_change_handler,
		input1_change_handler,
		input2_change_handler,
		input3_change_handler
	];
}

class MediaInput extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9, create_fragment$i, safe_not_equal, {
			alt: 0,
			src: 1,
			opts: 2,
			klass: 3,
			setMedia: 10,
			delMedia: 4,
			cancel: 11,
			media_type: 5,
			mouseX: 9,
			base_node: 12
		});
	}
}

/* src/Editor/Editor.svelte generated by Svelte v3.24.1 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[39] = list;
	child_ctx[40] = i;
	return child_ctx;
}

// (166:0) {#if show_toolbar && editable}
function create_if_block_1$2(ctx) {
	let toolbar;
	let current;

	toolbar = new ToolBar({
			props: {
				setGClass: /*setGClass*/ ctx[4],
				setClass: /*setClass*/ ctx[3],
				base_node: /*base_node*/ ctx[5],
				g_classes: /*g_classes*/ ctx[7],
				classes: /*classes*/ ctx[6],
				href: /*href*/ ctx[8],
				mouseX: /*mouseX*/ ctx[9]
			}
		});

	toolbar.$on("close", /*hideSelect*/ ctx[15]);

	return {
		c() {
			create_component(toolbar.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toolbar, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toolbar_changes = {};
			if (dirty[0] & /*setGClass*/ 16) toolbar_changes.setGClass = /*setGClass*/ ctx[4];
			if (dirty[0] & /*setClass*/ 8) toolbar_changes.setClass = /*setClass*/ ctx[3];
			if (dirty[0] & /*base_node*/ 32) toolbar_changes.base_node = /*base_node*/ ctx[5];
			if (dirty[0] & /*g_classes*/ 128) toolbar_changes.g_classes = /*g_classes*/ ctx[7];
			if (dirty[0] & /*classes*/ 64) toolbar_changes.classes = /*classes*/ ctx[6];
			if (dirty[0] & /*href*/ 256) toolbar_changes.href = /*href*/ ctx[8];
			if (dirty[0] & /*mouseX*/ 512) toolbar_changes.mouseX = /*mouseX*/ ctx[9];
			toolbar.$set(toolbar_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toolbar, detaching);
		}
	};
}

// (178:0) {#if show_media && editable}
function create_if_block$6(ctx) {
	let mediainput;
	let current;

	const mediainput_spread_levels = [
		{ setMedia: /*addMedia*/ ctx[19] },
		{ delMedia: /*rmMedia*/ ctx[20] },
		{ cancel: /*func*/ ctx[27] },
		{ base_node: /*base_node*/ ctx[5] },
		/*img_props*/ ctx[11],
		{ mouseX: /*mouseX*/ ctx[9] }
	];

	let mediainput_props = {};

	for (let i = 0; i < mediainput_spread_levels.length; i += 1) {
		mediainput_props = assign(mediainput_props, mediainput_spread_levels[i]);
	}

	mediainput = new MediaInput({ props: mediainput_props });

	return {
		c() {
			create_component(mediainput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(mediainput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const mediainput_changes = (dirty[0] & /*addMedia, rmMedia, show_media, base_node, img_props, mouseX*/ 1576480)
			? get_spread_update(mediainput_spread_levels, [
					dirty[0] & /*addMedia*/ 524288 && { setMedia: /*addMedia*/ ctx[19] },
					dirty[0] & /*rmMedia*/ 1048576 && { delMedia: /*rmMedia*/ ctx[20] },
					dirty[0] & /*show_media*/ 1024 && { cancel: /*func*/ ctx[27] },
					dirty[0] & /*base_node*/ 32 && { base_node: /*base_node*/ ctx[5] },
					dirty[0] & /*img_props*/ 2048 && get_spread_object(/*img_props*/ ctx[11]),
					dirty[0] & /*mouseX*/ 512 && { mouseX: /*mouseX*/ ctx[9] }
				])
			: {};

			mediainput.$set(mediainput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(mediainput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(mediainput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(mediainput, detaching);
		}
	};
}

// (183:2) {#each arr_html as h, i}
function create_each_block$2(ctx) {
	let contenteditor;
	let updating_html;
	let updating_gklass;
	let current;

	function contenteditor_html_binding(value) {
		/*contenteditor_html_binding*/ ctx[28].call(null, value, /*h*/ ctx[38]);
	}

	function contenteditor_gklass_binding(value) {
		/*contenteditor_gklass_binding*/ ctx[29].call(null, value, /*h*/ ctx[38]);
	}

	function enter_handler(...args) {
		return /*enter_handler*/ ctx[30](/*i*/ ctx[40], ...args);
	}

	function merge_prev_handler(...args) {
		return /*merge_prev_handler*/ ctx[31](/*i*/ ctx[40], ...args);
	}

	function merge_next_handler(...args) {
		return /*merge_next_handler*/ ctx[32](/*i*/ ctx[40], ...args);
	}

	let contenteditor_props = { editable: /*editable*/ ctx[1] };

	if (/*h*/ ctx[38].html !== void 0) {
		contenteditor_props.html = /*h*/ ctx[38].html;
	}

	if (/*h*/ ctx[38].klass !== void 0) {
		contenteditor_props.gklass = /*h*/ ctx[38].klass;
	}

	contenteditor = new ContentEditor({ props: contenteditor_props });
	binding_callbacks.push(() => bind(contenteditor, "html", contenteditor_html_binding));
	binding_callbacks.push(() => bind(contenteditor, "gklass", contenteditor_gklass_binding));
	contenteditor.$on("enter", enter_handler);
	contenteditor.$on("merge_prev", merge_prev_handler);
	contenteditor.$on("merge_next", merge_next_handler);
	contenteditor.$on("select", /*showToolBar*/ ctx[14]);
	contenteditor.$on("hideselect", /*hideSelect*/ ctx[15]);
	contenteditor.$on("set_media", /*setMediaInfo*/ ctx[18]);
	contenteditor.$on("input", /*contentUpdated*/ ctx[22]);
	contenteditor.$on("changeClass", /*disaptchChange*/ ctx[24]);
	contenteditor.$on("blur", /*triggerUpdate*/ ctx[23]);

	return {
		c() {
			create_component(contenteditor.$$.fragment);
		},
		m(target, anchor) {
			mount_component(contenteditor, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const contenteditor_changes = {};
			if (dirty[0] & /*editable*/ 2) contenteditor_changes.editable = /*editable*/ ctx[1];

			if (!updating_html && dirty[0] & /*arr_html*/ 1) {
				updating_html = true;
				contenteditor_changes.html = /*h*/ ctx[38].html;
				add_flush_callback(() => updating_html = false);
			}

			if (!updating_gklass && dirty[0] & /*arr_html*/ 1) {
				updating_gklass = true;
				contenteditor_changes.gklass = /*h*/ ctx[38].klass;
				add_flush_callback(() => updating_gklass = false);
			}

			contenteditor.$set(contenteditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(contenteditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(contenteditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(contenteditor, detaching);
		}
	};
}

function create_fragment$j(ctx) {
	let t0;
	let t1;
	let div;
	let setListEditors_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*show_toolbar*/ ctx[2] && /*editable*/ ctx[1] && create_if_block_1$2(ctx);
	let if_block1 = /*show_media*/ ctx[10] && /*editable*/ ctx[1] && create_if_block$6(ctx);
	let each_value = /*arr_html*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "key", "ed");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "mousedown", /*triggerChange*/ ctx[21]),
					action_destroyer(setListEditors_action = /*setListEditors*/ ctx[13].call(null, div))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_toolbar*/ ctx[2] && /*editable*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_toolbar, editable*/ 6) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*show_media*/ ctx[10] && /*editable*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*show_media, editable*/ 1026) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*editable, arr_html, addNewElm, mergePrev, mergeNext, showToolBar, hideSelect, setMediaInfo, contentUpdated, disaptchChange, triggerUpdate*/ 29872131) {
				each_value = /*arr_html*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function getParentEditor(target) {
	while (!target.dataset.editor && target.parentNode && target.parentNode.tagName) {
		target = target.parentNode;
	}

	// if target found
	if (target.dataset.editor) {
		return target;
	}

	return false;
}

function instance$a($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { arr_html = [{ html: ``, klass: "p-2" }] } = $$props;
	let { editable = false } = $$props;
	let { html = "" } = $$props;
	let { uid = null } = $$props;

	async function addNewElm(i, evt) {
		// split
		// get element index
		let target = evt.detail.target;

		let index = [...target.parentNode.children].indexOf(target);

		arr_html.splice(
			i,
			1,
			{
				html: evt.detail.html,
				klass: evt.detail.klass
			},
			{
				html: evt.detail.next_html,
				klass: evt.detail.klass
			}
		);

		// auto focus
		$$invalidate(0, arr_html);

		await new Promise(r => setTimeout(r));

		// find next div index in cildren
		let div_editors = [...list_editors.children].filter(e => e.tagName == "DIV");

		// next element
		let j = 1;

		while (!div_editors[index + j].getAttribute("contenteditable")) {
			j++;
		}

		div_editors[index + j].focus();
	}

	let list_editors;

	function setListEditors(node) {
		list_editors = node;
	}

	let show_toolbar = false;
	let setClass;
	let setGClass;
	let base_node;
	let classes;
	let g_classes;
	let href;
	let mouseX;

	function showToolBar(evt) {
		$$invalidate(5, base_node = evt.detail.base_node);
		if (!base_node || base_node.tagName == "DIV") return;
		$$invalidate(2, show_toolbar = true);
		$$invalidate(3, setClass = evt.detail.setClass);
		$$invalidate(4, setGClass = evt.detail.setGClass);
		$$invalidate(6, classes = evt.detail.classes);
		$$invalidate(7, g_classes = evt.detail.g_classes);
		$$invalidate(8, href = evt.detail.href);
		$$invalidate(9, mouseX = evt.detail.mouseX);
	}

	function hideSelect() {
		$$invalidate(2, show_toolbar = false);
	}

	function mergePrev(evt, i) {
		if (i > 0) {
			$$invalidate(0, arr_html[i - 1].html += evt.detail, arr_html);
			arr_html.splice(i, 1);
			$$invalidate(0, arr_html);
		}
	}

	function mergeNext(evt, i) {
		if (i + 1 < arr_html.length) {
			$$invalidate(0, arr_html[i].html += arr_html[i + 1].html, arr_html);
			arr_html.splice(i + 1, 1);
			$$invalidate(0, arr_html);
		}
	}

	let setMedia;
	let delMedia;
	let show_media = false;
	let img_props = {};

	function setMediaInfo(evt) {
		setMedia = evt.detail.setMedia;
		delMedia = evt.detail.delMedia;
		$$invalidate(5, base_node = evt.detail.base_node);

		$$invalidate(11, img_props = {
			alt: evt.detail.alt || "",
			src: evt.detail.src || "",
			opts: evt.detail.opts || {},
			klass: evt.detail.klass || "",
			media_type: evt.detail.media_type
		});

		$$invalidate(9, mouseX = evt.detail.mouseX);

		// show toolbar setmedia
		setMedia(img_props);

		$$invalidate(10, show_media = true);
	}

	function addMedia(img) {
		setMedia(img);
		$$invalidate(10, show_media = false);
		disaptchChange();
	}

	function rmMedia() {
		delMedia();
		$$invalidate(10, show_media = false);
		disaptchChange();
	}

	function triggerChange(e) {
		// trigger change if click is not on the current editor
		let pEditor = getParentEditor(e.target);

		if (!pEditor || pEditor.dataset.uid !== uid) {
			triggerUpdate();
			hideSelect();
		}
	}

	let updated = false;

	function contentUpdated() {
		updated = true;
	}

	function triggerUpdate() {
		if (updated && !show_toolbar) {
			disaptchChange();
			updated = false;
		}
	}

	function disaptchChange() {
		dispatch("change", { uid, arr_html });
	}

	const func = () => $$invalidate(10, show_media = false);

	function contenteditor_html_binding(value, h) {
		h.html = value;
		$$invalidate(0, arr_html);
	}

	function contenteditor_gklass_binding(value, h) {
		h.klass = value;
		$$invalidate(0, arr_html);
	}

	const enter_handler = (i, evt) => addNewElm(i, evt);
	const merge_prev_handler = (i, evt) => mergePrev(evt, i);
	const merge_next_handler = (i, evt) => mergeNext(evt, i);

	$$self.$$set = $$props => {
		if ("arr_html" in $$props) $$invalidate(0, arr_html = $$props.arr_html);
		if ("editable" in $$props) $$invalidate(1, editable = $$props.editable);
		if ("html" in $$props) $$invalidate(25, html = $$props.html);
		if ("uid" in $$props) $$invalidate(26, uid = $$props.uid);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*arr_html*/ 1) {
			 $$invalidate(25, html = arr_html.map(h => `<div class='${h.klass}'>${h.html}</div>`).join("\n"));
		}
	};

	return [
		arr_html,
		editable,
		show_toolbar,
		setClass,
		setGClass,
		base_node,
		classes,
		g_classes,
		href,
		mouseX,
		show_media,
		img_props,
		addNewElm,
		setListEditors,
		showToolBar,
		hideSelect,
		mergePrev,
		mergeNext,
		setMediaInfo,
		addMedia,
		rmMedia,
		triggerChange,
		contentUpdated,
		triggerUpdate,
		disaptchChange,
		html,
		uid,
		func,
		contenteditor_html_binding,
		contenteditor_gklass_binding,
		enter_handler,
		merge_prev_handler,
		merge_next_handler
	];
}

class Editor extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$a,
			create_fragment$j,
			safe_not_equal,
			{
				arr_html: 0,
				editable: 1,
				html: 25,
				uid: 26
			},
			[-1, -1]
		);
	}
}

export default Editor;
